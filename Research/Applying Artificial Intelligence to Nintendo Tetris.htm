<!DOCTYPE html>
<html><head>
    <link rel="stylesheet" href="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/style.css" type="text/css">
    <title>Applying Artificial Intelligence to Nintendo Tetris</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  </head>
  <body>
    <h1>Applying Artificial Intelligence to Nintendo Tetris</h1>
    <h2><a id="Abstract">Abstract</a></h2>    
    <p>In this article, I explore the deceptively simple mechanics of Nintendo Tetris.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/75.png"></p>
    <p>Afterwards, I describe how to build an AI that exploits them.</p>
    
    <h2><a id="Table_of_Contents">Table of Contents</a></h2>
    <p class="i0"><a href="#Abstract">Abstract</a></p>
    <p class="i0"><a href="#Table_of_Contents">Table of Contents</a></p>
    <p class="i0"><a href="#Try_It_Yourself">Try It Yourself</a></p>
    <p class="i1"><a href="#About">About</a></p>
    <p class="i1"><a href="#Preliminaries">Preliminaries</a></p>
    <p class="i1"><a href="#Download">Download</a></p>
    <p class="i1"><a href="#Run">Run</a></p>
    <p class="i1"><a href="#Configuration">Configuration</a></p>
    <p class="i0"><a href="#The_Mechanics_of_Nintendo_Tetris">The Mechanics of Nintendo Tetris</a></p>
    <p class="i1"><a href="#Representing_Tetriminos">Representing Tetriminos</a></p>
    <p class="i1"><a href="#Rotating_Tetriminos">Rotating Tetriminos</a></p>
    <p class="i1"><a href="#Spawning_Tetriminos">Spawning Tetriminos</a></p>
    <p class="i1"><a href="#Picking_Tetriminos">Picking Tetriminos</a></p>
    <p class="i1"><a href="#Shifting_Tetriminos">Shifting Tetriminos</a></p>
    <p class="i1"><a href="#Dropping_Tetriminos">Dropping Tetriminos</a></p>
    <p class="i1"><a href="#Slides_and_Spins">Slides and Spins</a></p>
    <p class="i1"><a href="#Level_30_and_Beyond">Level 30 and Beyond</a></p>
    <p class="i1"><a href="#Lines_and_Statistics">Lines and Statistics</a></p>
    <p class="i1"><a href="#Coloring_Tetriminos">Coloring Tetriminos</a></p>
    <p class="i1"><a href="#Game_Mode">Game Mode</a></p>
    <p class="i1"><a href="#Legal_Screen">Legal Screen</a></p>
    <p class="i1"><a href="#Demo">Demo</a></p>
    <p class="i1"><a href="#The_Kill_Screen">The Kill Screen</a></p>
    <p class="i1"><a href="#Endings">Endings</a></p>
    <p class="i1"><a href="#2_Player_Versus">2 Player Versus</a></p>
    <p class="i1"><a href="#Music">Music and Sound Effects</a></p>
    <p class="i1"><a href="#Play_States_and_Render_Modes">Play States and Render Modes</a></p>
    <p class="i0"><a href="#The_Algorithm">The Algorithm</a></p>
    <p class="i1"><a href="#Overview">Overview</a></p>
    <p class="i1"><a href="#Searching_for_Lock">Searching for Lock</a></p>
    <p class="i1"><a href="#Evaluation_Function">Evaluation Function</a></p>
    <p class="i1"><a href="#Other_Factors">Other Factors</a></p>
    <p class="i1"><a href="#AI_Training">AI Training</a></p>
    <p class="i1"><a href="#Java_Version">Java Version</a></p>
    <p class="i2"><a href="#About2">About</a></p>
    <p class="i2"><a href="#Packages">Packages</a></p>
    <p class="i2"><a href="#AI_Classes_and_Interfaces">AI Classes and Interfaces</a></p>
    <p class="i2"><a href="#Invoking_the_AI">Invoking the AI</a></p>
    <p class="i2"><a href="#Displaying_the_Playfield">Displaying the Playfield</a></p>
    <p class="i2"><a href="#Other_Projects">Other Projects</a></p>
    <p class="i1"><a href="#Gamepad_Version">Gamepad Version</a></p>
    
    <h2><a id="Try_It_Yourself">Try It Yourself</a></h2>    
    <h3><a id="About">About</a></h3>
    <p>For those lacking the persistence, patience and time necessary to
 master Nintendo Tetris, I created an AI to play it for you.  Finally, 
you can experience level 30 and beyond.  You can witness the score max 
out while the line, level and statistics counters wraparound 
indefinitely.  Find out what colors appear in levels higher than any 
human has ever reached.  Discover how long it can go.</p>
    <h3><a id="Preliminaries">Preliminaries</a></h3>
    <p>To run the AI, you'll need <a href="http://www.fceux.com/">FCEUX</a>, the all-in-one NES/Famicom emulator.  The AI was developed for <a href="http://www.fceux.com/web/version.html">FCEUX 2.2.2</a>, the most recent version at the time of this writing.</p>
    <p>You'll also need the Nintendo Tetris ROM file (USA version).  <a href="https://www.google.com/#q=Tetris+NES+ROM+USA">Google</a> might be able to help you to track it down.</p>
    <h3><a id="Download">Download</a></h3>
    <p>Extract <span class="code">lua/NintendoTetrisAI.lua</span> from this <a href="http://meatfighter.com/nintendotetrisai/NintendoTetrisAI.zip">source zip</a>.</p>
    <h3><a id="Run">Run</a></h3>
    <p>Start up FCEUX.</p>  
    <p>From the menu bar, select File | Open ROM...  In the Open File 
dialog box, select the Nintendo Tetris ROM file and press Open.  The 
game will launch.</p>
    <p>From the menu bar, select File | Lua | New Lua Script Window...  From the Lua Script window, enter the path to <span class="code">NintendoTetrisAI.lua</span> or hit the Browse button to navigate to it.  Finally, press Run.</p>  
    <p>The Lua script will direct you to the first menu screen.  Leave 
the game type as A-Type, but feel free to change the music using the 
arrow keys.  On slower computers, the music may play choppy; you might 
want to disable it completely.  Press Start (Enter) to advance to the 
next menu screen.  In the second menu, you can change the starting level
 using the arrow keys.  Press Start to begin the game.  The AI will take
 over from there.</p>  
    <p>From the second menu screen, after you select the level, if you 
hold down gamepad button A (use Config | Input... to modify the keyboard
 mapping) and press Start, the resulting starting level will be 10 plus 
the selected value.  The highest starting level is 19.</p>
    
    <h3><a id="Configuration">Configuration</a></h3>
    <p>To make it play faster, open the Lua script in a text editor.  Toward the top of the file, you'll find the following line.</p>
    <p><span class="code">PLAY_FAST = false</span></p>
    <p>Change <span class="code">false</span> to <span class="code">true</span> as listed below.</p>
    <p><span class="code">PLAY_FAST = true</span></p>
    <p>Save the file.  Then, hit the Restart button on the Lua Script window.</p>
    
    <h2><a id="The_Mechanics_of_Nintendo_Tetris">The Mechanics of Nintendo Tetris</a></h2>
    <h3><a id="Representing_Tetriminos">Representing Tetriminos</a></h3>
    <p>Each Tetrimino (tetri-mee-noh) has a single-character name that resembles its shape.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/7.png"></p>
    <p>The designers of Nintendo Tetris arbitrarily ordered the 
Tetriminos into the sequence shown above.  The pieces are depicted in 
the spawn orientations and the arrangement produces a nearly symmetric 
image, which might explain why they chose this ordering.  The index into
 the sequence provides each Tetrimino with a unique numerical type ID.  
The sequence and the type IDs are important at a programmatic level, but
 it also manifests itself in the order of the pieces displayed in the 
statistics area (see below).</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/8.png"></p>
    <p>The 19 orientations of Tetriminos used by Nintendo Tetris are encoded in a table located at <span class="code">$8A9C</span> within NES memory.  Each piece is represented as a sequence of 12 bytes that can be broken down into triples, <span class="nowrap"><span class="code">(Y, tile, X)</span></span>, describing each square within the piece.  Hex coordinate values above <span class="code">$7F</span> represent negative integers (<span class="nowrap"><span class="code">$FF</span> = −1</span> and <span class="nowrap"><span class="code">$FE</span> = −2</span>).</p>
    <div class="centered"><div class="source"><pre>    <span class="comment">; Y0 T0 X0  Y1 T1 X1  Y2 T2 X2  Y3 T3 X3</span>
                        
8A9C: <span class="num">00 7B FF  00 7B 00  00 7B 01  FF 7B 00</span>  <span class="comment">; 00: T up</span>
8AA8: <span class="num">FF 7B 00  00 7B 00  00 7B 01  01 7B 00</span>  <span class="comment">; 01: T right</span>
8AB4: <span class="num">00 7B FF  00 7B 00  00 7B 01  01 7B 00</span>  <span class="comment">; 02: T down (spawn)</span>
8AC0: <span class="num">FF 7B 00  00 7B FF  00 7B 00  01 7B 00</span>  <span class="comment">; 03: T left</span>

8ACC: <span class="num">FF 7D 00  00 7D 00  01 7D FF  01 7D 00</span>  <span class="comment">; 04: J left</span>
8AD8: <span class="num">FF 7D FF  00 7D FF  00 7D 00  00 7D 01</span>  <span class="comment">; 05: J up</span>
8AE4: <span class="num">FF 7D 00  FF 7D 01  00 7D 00  01 7D 00</span>  <span class="comment">; 06: J right</span>
8AF0: <span class="num">00 7D FF  00 7D 00  00 7D 01  01 7D 01</span>  <span class="comment">; 07: J down (spawn)</span>

8AFC: <span class="num">00 7C FF  00 7C 00  01 7C 00  01 7C 01</span>  <span class="comment">; 08: Z horizontal (spawn)</span>
8B08: <span class="num">FF 7C 01  00 7C 00  00 7C 01  01 7C 00</span>  <span class="comment">; 09: Z vertical</span>

8B14: <span class="num">00 7B FF  00 7B 00  01 7B FF  01 7B 00</span>  <span class="comment">; 0A: O (spawn)</span>

8B20: <span class="num">00 7D 00  00 7D 01  01 7D FF  01 7D 00</span>  <span class="comment">; 0B: S horizontal (spawn)</span>
8B2C: <span class="num">FF 7D 00  00 7D 00  00 7D 01  01 7D 01</span>  <span class="comment">; 0C: S vertical</span>

8B38: <span class="num">FF 7C 00  00 7C 00  01 7C 00  01 7C 01</span>  <span class="comment">; 0D: L right</span>
8B44: <span class="num">00 7C FF  00 7C 00  00 7C 01  01 7C FF</span>  <span class="comment">; 0E: L down (spawn)</span>
8B50: <span class="num">FF 7C FF  FF 7C 00  00 7C 00  01 7C 00</span>  <span class="comment">; 0F: L left</span>
8B5C: <span class="num">FF 7C 01  00 7C FF  00 7C 00  00 7C 01</span>  <span class="comment">; 10: L up</span>

8B68: <span class="num">FE 7B 00  FF 7B 00  00 7B 00  01 7B 00</span>  <span class="comment">; 11: I vertical</span>
8B74: <span class="num">00 7B FE  00 7B FF  00 7B 00  00 7B 01</span>  <span class="comment">; 12: I horizontal (spawn)</span>
        
8B80: <span class="num">00 FF 00  00 FF 00  00 FF 00  00 FF 00</span>  <span class="comment">; 13: Unused</span></pre></div></div> 
    <p>There is one unused entry at the bottom of the table potentially 
providing the means of adding an extra orientation.  However, in various
 parts of the code, <span class="code">$13</span> indicates that the active Tetrimino's orientation ID is not assigned a value.</p>
    <p>The square coordinates are re-expressed in decimal below to make it easier to read.</p>
    <div class="centered"><div class="source"><pre><span class="comment">-- { { X0, Y0 }, { X1, Y1 }, { X2, Y2 }, { X3, Y3 }, },</span>

   { { <span class="num">-1</span>,  <span class="num">0</span> }, {  <span class="num">0</span>,  <span class="num">0</span> }, {  <span class="num">1</span>,  <span class="num">0</span> }, {  <span class="num">0</span>, <span class="num">-1</span> }, },  <span class="comment">-- 00: T up</span>
   { {  <span class="num">0</span>, <span class="num">-1</span> }, {  <span class="num">0</span>,  <span class="num">0</span> }, {  <span class="num">1</span>,  <span class="num">0</span> }, {  <span class="num">0</span>,  <span class="num">1</span> }, },  <span class="comment">-- 01: T right</span>
   { { <span class="num">-1</span>,  <span class="num">0</span> }, {  <span class="num">0</span>,  <span class="num">0</span> }, {  <span class="num">1</span>,  <span class="num">0</span> }, {  <span class="num">0</span>,  <span class="num">1</span> }, },  <span class="comment">-- 02: T down (spawn)</span>
   { {  <span class="num">0</span>, <span class="num">-1</span> }, { <span class="num">-1</span>,  <span class="num">0</span> }, {  <span class="num">0</span>,  <span class="num">0</span> }, {  <span class="num">0</span>,  <span class="num">1</span> }, },  <span class="comment">-- 03: T left</span>

   { {  <span class="num">0</span>, <span class="num">-1</span> }, {  <span class="num">0</span>,  <span class="num">0</span> }, { <span class="num">-1</span>,  <span class="num">1</span> }, {  <span class="num">0</span>,  <span class="num">1</span> }, },  <span class="comment">-- 04: J left</span>
   { { <span class="num">-1</span>, <span class="num">-1</span> }, { <span class="num">-1</span>,  <span class="num">0</span> }, {  <span class="num">0</span>,  <span class="num">0</span> }, {  <span class="num">1</span>,  <span class="num">0</span> }, },  <span class="comment">-- 05: J up</span>
   { {  <span class="num">0</span>, <span class="num">-1</span> }, {  <span class="num">1</span>, <span class="num">-1</span> }, {  <span class="num">0</span>,  <span class="num">0</span> }, {  <span class="num">0</span>,  <span class="num">1</span> }, },  <span class="comment">-- 06: J right</span>
   { { <span class="num">-1</span>,  <span class="num">0</span> }, {  <span class="num">0</span>,  <span class="num">0</span> }, {  <span class="num">1</span>,  <span class="num">0</span> }, {  <span class="num">1</span>,  <span class="num">1</span> }, },  <span class="comment">-- 07: J down (spawn)</span>

   { { <span class="num">-1</span>,  <span class="num">0</span> }, {  <span class="num">0</span>,  <span class="num">0</span> }, {  <span class="num">0</span>,  <span class="num">1</span> }, {  <span class="num">1</span>,  <span class="num">1</span> }, },  <span class="comment">-- 08: Z horizontal (spawn) </span>
   { {  <span class="num">1</span>, <span class="num">-1</span> }, {  <span class="num">0</span>,  <span class="num">0</span> }, {  <span class="num">1</span>,  <span class="num">0</span> }, {  <span class="num">0</span>,  <span class="num">1</span> }, },  <span class="comment">-- 09: Z vertical</span>

   { { <span class="num">-1</span>,  <span class="num">0</span> }, {  <span class="num">0</span>,  <span class="num">0</span> }, { <span class="num">-1</span>,  <span class="num">1</span> }, {  <span class="num">0</span>,  <span class="num">1</span> }, },  <span class="comment">-- 0A: O (spawn)</span>

   { {  <span class="num">0</span>,  <span class="num">0</span> }, {  <span class="num">1</span>,  <span class="num">0</span> }, { <span class="num">-1</span>,  <span class="num">1</span> }, {  <span class="num">0</span>,  <span class="num">1</span> }, },  <span class="comment">-- 0B: S horizontal (spawn)</span>
   { {  <span class="num">0</span>, <span class="num">-1</span> }, {  <span class="num">0</span>,  <span class="num">0</span> }, {  <span class="num">1</span>,  <span class="num">0</span> }, {  <span class="num">1</span>,  <span class="num">1</span> }, },  <span class="comment">-- 0C: S vertical</span>

   { {  <span class="num">0</span>, <span class="num">-1</span> }, {  <span class="num">0</span>,  <span class="num">0</span> }, {  <span class="num">0</span>,  <span class="num">1</span> }, {  <span class="num">1</span>,  <span class="num">1</span> }, },  <span class="comment">-- 0D: L right</span>
   { { <span class="num">-1</span>,  <span class="num">0</span> }, {  <span class="num">0</span>,  <span class="num">0</span> }, {  <span class="num">1</span>,  <span class="num">0</span> }, { <span class="num">-1</span>,  <span class="num">1</span> }, },  <span class="comment">-- 0E: L down (spawn)</span>
   { { <span class="num">-1</span>, <span class="num">-1</span> }, {  <span class="num">0</span>, <span class="num">-1</span> }, {  <span class="num">0</span>,  <span class="num">0</span> }, {  <span class="num">0</span>,  <span class="num">1</span> }, },  <span class="comment">-- 0F: L left</span>
   { {  <span class="num">1</span>, <span class="num">-1</span> }, { <span class="num">-1</span>,  <span class="num">0</span> }, {  <span class="num">0</span>,  <span class="num">0</span> }, {  <span class="num">1</span>,  <span class="num">0</span> }, },  <span class="comment">-- 10: L up</span>

   { {  <span class="num">0</span>, <span class="num">-2</span> }, {  <span class="num">0</span>, <span class="num">-1</span> }, {  <span class="num">0</span>,  <span class="num">0</span> }, {  <span class="num">0</span>,  <span class="num">1</span> }, },  <span class="comment">-- 11: I vertical</span>
   { { <span class="num">-2</span>,  <span class="num">0</span> }, { <span class="num">-1</span>,  <span class="num">0</span> }, {  <span class="num">0</span>,  <span class="num">0</span> }, {  <span class="num">1</span>,  <span class="num">0</span> }, },  <span class="comment">-- 12: I horizontal (spawn)</span>
</pre></div></div> 
    <p>All of the orientations fit within a 5×5 matrix.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/1.png"></p>
    <p>Above, a white square marks the center of the matrix, the pivot point for piece rotation.</p>    
    <p>The orientation table is depicted graphically below.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/0.png"></p>
    <p>The orientation ID (the table index) is displayed in hexadecimal 
in the upper-right of each matrix.  And, a mnemonic invented for this 
discussion appears in the upper-lefts.  The lower-case <span class="code">u</span>, <span class="code">r</span>, <span class="code">d</span>, <span class="code">l</span>, <span class="code">h</span> and <span class="code">v</span> are short for up, right, down, left, horizontal and vertical respectively.  It's easier to refer to <span class="code">Jd</span> rather than <span class="code">$07</span>, for instance.</p>
    <p>The matrices containing spawn orientations are bordered in white.</p>        
    <p>Tetriminos I, S and Z could have been designed to have 4 distinct
 orientations, but the creators of Nintendo Tetris decided to limit them
 to 2. Also, <span class="code">Zv</span> and <span class="code">Sv</span> are not perfect mirrors of each other.  Both were produced via counterclockwise rotation resulting in an imbalance.</p>
    <p>The orientation table also contains the tile values for each 
square within each oriented piece.  However, a close inspection reveals 
that the values are all the same among Tetrimino type.</p>    
<table class="table1">    
<tbody><tr><th>T</th><th>J</th><th>Z</th><th>O</th><th>S</th><th>L</th><th>I</th></tr>
<tr><td><span class="code">7B</span></td><td><span class="code">7D</span></td><td><span class="code">7C</span></td><td><span class="code">7B</span></td><td><span class="code">7D</span></td><td><span class="code">7C</span></td><td><span class="code">7B</span></td></tr>    
</tbody></table>    
    <p>The tile values are indices into the (false-color) pattern table shown below.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/4.png"></p>
    <p>Tiles <span class="code">$7B</span>, <span class="code">$7C</span> and <span class="code">$7D</span>
 are located directly below, "ATIS", in the word, "STATISTICS".  They 
are the 3 types of squares from which Tetriminos are built.</p>
    <p>If you are wondering, the ostriches and penguins are from the B-Type endings, a topic further discussed <a href="#Endings">below</a>.</p>
    <p>Below is the result of modifying the ROM to change <span class="code">$7B</span> to <span class="code">$29</span>, the tile directly below character P in the pattern table, for all T orientations.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/5.png"></p>
    <p>The heart tiles remain in the playfield even after the modified T locks into place.  As discussed further <a href="#Spawning_Tetriminos">below</a>, this means that the playfield stores the actual tile index values from the played Tetriminos.</p>
    <p>The game programmers provided the means of using 4 separate tiles
 for each piece as opposed to just one consistent square type.  It's a 
useful feature that could be used to re-skin the game. There are plenty 
of empty spaces within the pattern table for new tiles that could give 
each Tetrimino a unique look.</p>
    <p>The square coordinates are just as easy to manipulate.  For 
example, below is a modified version of the first 4 triples in the 
orientation table.</p>
    <div class="centered"><div class="source"><pre>8A9C: <span class="num">FE 7B FE  FE 7B 02  02 7B FE  02 7B 02</span>  <span class="comment">; 00: T up</span></pre></div></div>
    <p>The change is equivalent to the following.</p>
    <div class="centered"><div class="source"><pre>   { { <span class="num">-2</span>, <span class="num">-2</span> }, {  <span class="num">2</span>, <span class="num">-2</span> }, { <span class="num">-2</span>,  <span class="num">2</span> }, {  <span class="num">2</span>,  <span class="num">2</span> }, },  <span class="comment">-- 00: T up</span></pre></div></div>
    <p>The result is a disjoint Tetrimino.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/6.png"></p>
    <p>When the disjoint Tetrimino is moved around, its squares are 
restricted to the boundaries of the playfield and they cannot pass 
through previously locked pieces.  Also, the game prohibits rotation to 
this orientation if it would result in a square outside of the playfield
 bounds or if it would cause a square to overlap a locked square.</p>  
    <p>The disjoint Tetrimino locks into place when any of its squares 
are supported.  And, when it locks, its floating squares remain 
floating.</p>
    <p>The game treats the disjoint Tetrimino as it would any other 
normal piece.  It reveals that there is no additional table containing 
piece metadata.  For example, a table could have been used that stores 
the bounding-box dimensions of each orientation for playfield perimeter 
collision testing.  But, no such table is used.  Instead, the game 
simply performs tests on all 4 squares just prior to manipulating a 
piece.</p>
    <p>In addition, the square coordinates can be any values; they are not restricted to <span class="nowrap">[−2, 2]</span>.
  Of course, values far outside of that range will yield unusable pieces
 that may not even fit in the playfield.  More importantly, as discussed
 <a href="#Play_States_and_Render_Modes">later</a>, when a piece locks 
in place, the mechanism that clears out completed lines only scans row 
offsets −2 to 1 about the piece origin; a square with a <span class="nowrap">y-coordinate</span> outside of that range will go undetected at that time.</p>
    <h3><a id="Rotating_Tetriminos">Rotating Tetriminos</a></h3>
    <p>In the graphical depiction of the orientation table, rotation 
involves moving from a matrix to one of the matrices directly to its 
left or right, wrapping around the row if necessary.  That concept is 
encoded in a table at <span class="code">$88EE</span>.</p>
    <div class="centered"><div class="source"><pre>             <span class="comment">; CCW  CW</span>
88EE: <span class="num">03 01</span>  <span class="comment">;  Tl  Tr</span>
88F0: <span class="num">00 02</span>  <span class="comment">;  Tu  Td</span>
88F2: <span class="num">01 03</span>  <span class="comment">;  Tr  Tl</span>
88F4: <span class="num">02 00</span>  <span class="comment">;  Td  Tu</span>
88F6: <span class="num">07 05</span>  <span class="comment">;  Jd  Ju</span>
88F8: <span class="num">04 06</span>  <span class="comment">;  Jl  Jr</span>
88FA: <span class="num">05 07</span>  <span class="comment">;  Ju  Jd</span>
88FC: <span class="num">06 04</span>  <span class="comment">;  Jr  Jl</span>
88FE: <span class="num">09 09</span>  <span class="comment">;  Zv  Zv</span>
8900: <span class="num">08 08</span>  <span class="comment">;  Zh  Zh</span>
8902: <span class="num">0A 0A</span>  <span class="comment">;  O   O</span>
8904: <span class="num">0C 0C</span>  <span class="comment">;  Sv  Sv</span>
8906: <span class="num">0B 0B</span>  <span class="comment">;  Sh  Sh</span>
8908: <span class="num">10 0E</span>  <span class="comment">;  Lu  Ld</span>
890A: <span class="num">0D 0F</span>  <span class="comment">;  Lr  Ll</span>
890C: <span class="num">0E 10</span>  <span class="comment">;  Ld  Lu</span>
890E: <span class="num">0F 0D</span>  <span class="comment">;  Ll  Lr</span>
8910: <span class="num">12 12</span>  <span class="comment">;  Ih  Ih</span>
8912: <span class="num">11 11</span>  <span class="comment">;  Iv  Iv</span></pre></div></div>        
    <p>To make this clearer, each column above was transposed to a row in the table below.</p>    
    <table class="table1">
      <tbody><tr><th class="hidden"></th><th><span class="code">Tu</span></th><th><span class="code">Tr</span></th><th><span class="code">Td</span></th><th><span class="code">Tl</span></th><th><span class="code">Jl</span></th><th><span class="code">Ju</span></th><th><span class="code">Jr</span></th><th><span class="code">Jd</span></th><th><span class="code">Zh</span></th><th><span class="code">Zv</span></th><th><span class="code">O</span></th><th><span class="code">Sh</span></th><th><span class="code">Sv</span></th><th><span class="code">Lr</span></th><th><span class="code">Ld</span></th><th><span class="code">Ll</span></th><th><span class="code">Lu</span></th><th><span class="code">Iv</span></th><th><span class="code">Ih</span></th></tr>
      <tr><th class="side">Counterclockwise</th><td><span class="code">Tl</span></td><td><span class="code">Tu</span></td><td><span class="code">Tr</span></td><td><span class="code">Td</span></td><td><span class="code">Jd</span></td><td><span class="code">Jl</span></td><td><span class="code">Ju</span></td><td><span class="code">Jr</span></td><td><span class="code">Zv</span></td><td><span class="code">Zh</span></td><td><span class="code">O</span></td><td><span class="code">Sv</span></td><td><span class="code">Sh</span></td><td><span class="code">Lu</span></td><td><span class="code">Lr</span></td><td><span class="code">Ld</span></td><td><span class="code">Ll</span></td><td><span class="code">Ih</span></td><td><span class="code">Iv</span></td></tr>
      <tr><th class="side">Clockwise</th><td><span class="code">Tr</span></td><td><span class="code">Td</span></td><td><span class="code">Tl</span></td><td><span class="code">Tu</span></td><td><span class="code">Ju</span></td><td><span class="code">Jr</span></td><td><span class="code">Jd</span></td><td><span class="code">Jl</span></td><td><span class="code">Zv</span></td><td><span class="code">Zh</span></td><td><span class="code">O</span></td><td><span class="code">Sv</span></td><td><span class="code">Sh</span></td><td><span class="code">Ld</span></td><td><span class="code">Ll</span></td><td><span class="code">Lu</span></td><td><span class="code">Lr</span></td><td><span class="code">Ih</span></td><td><span class="code">Iv</span></td></tr>
    </tbody></table>
    <p>The mnemonics in the headers across the top can be interpreted as
 an index into the sequence or a key into a map.  For instance, a 
counterclockwise rotation of <span class="code">Tu</span> produces <span class="code">Tl</span>, where as a clockwise rotation of <span class="code">Tu</span> produces <span class="code">Tr</span>.</p>
    <p>The rotation table encodes chained sequences of orientation IDs 
and consequentially, it is possible to modify entries such that rotation
 will have the effect of transforming one Tetrimino type into another.  
That technique could potentially be used to take advantage of the unused
 row in the orientation table.</p>
    <p>Preceding the rotation table is the code that accesses it.</p>
    <div class="centered"><div class="source"><pre>88AB: LDA $0042
88AD: STA $00AE    <span class="comment">; originalOrientationID = orientationID;</span> 

88AF: CLC
88B0: LDA $0042
88B2: ASL
88B3: TAX          <span class="comment">; index = 2 * orientationID;</span>

88B4: LDA $00B5    
88B6: AND #$80     <span class="comment">; if (not just pressed button A) {</span>
88B8: CMP #$80     <span class="comment">;   goto aNotPressed;</span>
88BA: BNE $88CF    <span class="comment">; }</span>

88BC: INX          
88BD: LDA $<span class="num">88EE</span>,X    
88C0: STA $0042    <span class="comment">; orientationID = rotationTable[index + 1];</span>

88C2: JSR $948B    <span class="comment">; if (new orientation not valid) {</span>
88C5: BNE $88E9    <span class="comment">;   goto restoreOrientationID;</span>
                   <span class="comment">; }</span>

88C7: LDA #$05     
88C9: STA $06F1    <span class="comment">; play rotation sound effect;</span>
88CC: JMP $88ED    <span class="comment">; return;</span>

<span class="label">aNotPressed:</span>

88CF: LDA $00B5
88D1: AND #$40     <span class="comment">; if (not just pressed button B) {</span>
88D3: CMP #$40     <span class="comment">;   return;</span>
88D5: BNE $88ED    <span class="comment">; }</span>

88D7: LDA $<span class="num">88EE</span>,X  
88DA: STA $0042    <span class="comment">; orientationID = rotationTable[index];</span>
 
88DC: JSR $948B    <span class="comment">; if (new orientation not valid) {</span>                  
88DF: BNE $88E9    <span class="comment">;   goto restoreOrientationID;</span>
                   <span class="comment">; }</span>

88E1: LDA #$05
88E3: STA $06F1    <span class="comment">; play rotation sound effect;</span>
88E6: JMP $88ED    <span class="comment">; return;</span>

<span class="label">restoreOrientationID:</span>

88E9: LDA $00AE                
88EB: STA $0042    <span class="comment">; orientationID = originalOrientationID;</span>

88ED: RTS          <span class="comment">; return;</span></pre></div></div>    
    <p>For counterclockwise rotation, the index of the rotation table is
 computed by doubling the orientation ID.  Adding 1 to that produces the
 index for clockwise rotation.</p>
    <p>The <span class="nowrap">x-coordinate</span>, the <span class="nowrap">y-coordinate</span> and the orientation ID of the Tetrimino in play are stored at <span class="code">$0040</span>, <span class="code">$0041</span> and <span class="code">$0042</span> respectively.</p>
    <p>The code uses a temporary variable to backup the orientation ID. 
 Later, after modifying the orientation, the code verifies that all 4 
squares are within the bounds of the playfield and that none them 
overlap a previously locked square (the <a href="#Slides_and_Spins">validation code</a> is at <span class="code">$948B</span>,
 beyond the snippet above).  If the new orientation is invalid, it 
restores back to the original, preventing the player from rotating.</p>
    <p>Including the D-pad, the NES controller has 8 buttons and the state of each is represented by a bit of <span class="code">$00B6</span>.</p>
    <table class="table2">
      <tbody><tr><th><span class="code">7</span></th><th><span class="code">6</span></th><th><span class="code">5</span></th><th><span class="code">4</span></th><th><span class="code">3</span></th><th><span class="code">2</span></th><th><span class="code">1</span></th><th><span class="code">0</span></th></tr>
      <tr><td>A</td><td>B</td><td>Select</td><td>Start</td><td>Up</td><td>Down</td><td>Left</td><td>Right</td></tr>
    </tbody></table>
    <p>For example, <span class="code">$00B6</span> will contain <span class="code">$81</span> for as long as the player holds down A and Left.</p>
    <p>On the other hand, <span class="code">$00B5</span> reports when buttons are pressed; the bits of <span class="code">$00B5</span> remain set for only one iteration of the game loop (1 rendered frame).  The code uses <span class="code">$00B5</span> to respond to A and B.  Each of them need to be released before they can be used again.</p>
    <p><span class="code">$00B5</span> and <span class="code">$00B6</span> are mirrors of <span class="code">$00F5</span> and <span class="code">$00F6</span> respectively.  Code in subsequent sections uses these addresses interchangeably.</p>
    
    <h3><a id="Spawning_Tetriminos">Spawning Tetriminos</a></h3>    
    <p>The Nintendo Tetris playfield consists of a matrix with 22 rows 
and 10 columns such that the top 2 rows are hidden from the player.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/2.png"></p>    
    <p>As seen in the snippet below, when a Tetrimino is spawned, it is always positioned at coordinates <span class="nowrap">(5, 0)</span> within the playfield.</p>    
    <div class="centered"><div class="source"><pre>98BA: <span class="num">LDA #$00</span>
98BC: STA $00A4
98BE: STA $0045
98C0: <span class="num">STA $0041</span>  <span class="comment">; Tetrimino Y = 0</span>
98C2: LDA #$01
98C4: STA $0048                           
98C6: <span class="num">LDA #$05</span>        
98C8: <span class="num">STA $0040</span>  <span class="comment">; Tetrimino X = 5</span></pre></div></div>    
    <p>Below, a 5×5 matrix is overlaid about that point.</p>    
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/3.png"></p>
    <p>None of the spawn matrices have squares above the origin.  
Meaning, when a Tetrimino is spawned, all 4 of its squares are 
immediately visible to the player.  However, if the player quickly 
rotates the piece before it has an opportunity to drop, part of the 
piece could be hidden temporarily in the first 2 rows of the playfield.</p>
    <p>In fact, normally, we think of game over as when the pile reaches
 the top.  But, this is not entirely correct.  The game actually ends 
when it is no longer possible to spawn the next piece.  That is, all 
four cells of the playfield corresponding to the spawned Tetrimino's 
square positions must be empty before the piece can be introduced.  A 
piece can be locked in place such that some of its squares end up in 
negatively numbered rows without ending the game; however, in Nintendo 
Tetris, negatively numbered rows are an abstraction that only applies to
 the active Tetrimino.  After a piece is locked, only the squares in 
rows 0 and above are recorded in the playfield.  Conceptually, it is as 
if the negatively number rows are automatically cleared after lock 
occurs.  But, in reality, the game simply doesn't store the data, 
potentially truncating away the upper part of pieces.</p>     
    <p>The 20×10 visible region of the playfield is stored at <span class="code">$0400</span> in row-major order, each byte containing a background tile value.  Empty cells are denoted by tile <span class="code">$EF</span>, a solid black square.</p>    
    <p>Three lookup tables are used during spawning.  Given an arbitrary orientation ID, the table at <span class="code">$9956</span> provides the spawn orientation ID for the associated Tetrimino type.</p>
    <div class="centered"><div class="source"><pre>9956: <span class="num">02 02 02 02</span>  <span class="comment">; Td</span>
995A: <span class="num">07 07 07 07</span>  <span class="comment">; Jd</span>
995E: <span class="num">08 08</span>        <span class="comment">; Zh</span>
9960: <span class="num">0A</span>           <span class="comment">; O</span>
9961: <span class="num">0B 0B</span>        <span class="comment">; Sh</span>
9963: <span class="num">0E 0E 0E 0E</span>  <span class="comment">; Ld</span>
9967: <span class="num">12 12</span>        <span class="comment">; Ih</span></pre></div></div>   
    <p>This is easier to visualize with the representation below.</p>
    <table class="table1">
      <tbody><tr><th><span class="code">Tu</span></th><th><span class="code">Tr</span></th><th><span class="code">Td</span></th><th><span class="code">Tl</span></th><th><span class="code">Jl</span></th><th><span class="code">Ju</span></th><th><span class="code">Jr</span></th><th><span class="code">Jd</span></th><th><span class="code">Zh</span></th><th><span class="code">Zv</span></th><th><span class="code">O</span></th><th><span class="code">Sh</span></th><th><span class="code">Sv</span></th><th><span class="code">Lr</span></th><th><span class="code">Ld</span></th><th><span class="code">Ll</span></th><th><span class="code">Lu</span></th><th><span class="code">Iv</span></th><th><span class="code">Ih</span></th></tr>
      <tr><td><span class="code">Td</span></td><td><span class="code">Td</span></td><td><span class="code">Td</span></td><td><span class="code">Td</span></td><td><span class="code">Jd</span></td><td><span class="code">Jd</span></td><td><span class="code">Jd</span></td><td><span class="code">Jd</span></td><td><span class="code">Zh</span></td><td><span class="code">Zh</span></td><td><span class="code">O</span></td><td><span class="code">Sh</span></td><td><span class="code">Sh</span></td><td><span class="code">Ld</span></td><td><span class="code">Ld</span></td><td><span class="code">Ld</span></td><td><span class="code">Ld</span></td><td><span class="code">Ih</span></td><td><span class="code">Ih</span></td></tr>
    </tbody></table>
    <p>For instance, all J orientations map to <span class="code">Jd</span>.</p>
    <p>The table at <span class="code">$993B</span> provides Tetrimino type for a given orientation ID.</p>
    <div class="centered"><div class="source"><pre>993B: <span class="num">00 00 00 00</span>  <span class="comment">; T</span>
993F: <span class="num">01 01 01 01</span>  <span class="comment">; J</span>
9943: <span class="num">02 02</span>        <span class="comment">; Z</span>
9945: <span class="num">03</span>           <span class="comment">; O</span>
9946: <span class="num">04 04</span>        <span class="comment">; S</span>
9948: <span class="num">05 05 05 05</span>  <span class="comment">; L</span>
994C: <span class="num">06 06</span>        <span class="comment">; I</span></pre></div></div>
    <p>For clarity, it is expressed in tabular form below.</p>
    <table class="table1">
      <tbody><tr><th><span class="code">Tu</span></th><th><span class="code">Tr</span></th><th><span class="code">Td</span></th><th><span class="code">Tl</span></th><th><span class="code">Jl</span></th><th><span class="code">Ju</span></th><th><span class="code">Jr</span></th><th><span class="code">Jd</span></th><th><span class="code">Zh</span></th><th><span class="code">Zv</span></th><th><span class="code">O</span></th><th><span class="code">Sh</span></th><th><span class="code">Sv</span></th><th><span class="code">Lr</span></th><th><span class="code">Ld</span></th><th><span class="code">Ll</span></th><th><span class="code">Lu</span></th><th><span class="code">Iv</span></th><th><span class="code">Ih</span></th></tr>
      <tr><td><span class="code">T</span></td><td><span class="code">T</span></td><td><span class="code">T</span></td><td><span class="code">T</span></td><td><span class="code">J</span></td><td><span class="code">J</span></td><td><span class="code">J</span></td><td><span class="code">J</span></td><td><span class="code">Z</span></td><td><span class="code">Z</span></td><td><span class="code">O</span></td><td><span class="code">S</span></td><td><span class="code">S</span></td><td><span class="code">L</span></td><td><span class="code">L</span></td><td><span class="code">L</span></td><td><span class="code">L</span></td><td><span class="code">I</span></td><td><span class="code">I</span></td></tr>
    </tbody></table> 
    <p>The third lookup table is discussed in the following section.</p>
    
    <h3><a id="Picking_Tetriminos">Picking Tetriminos</a></h3>
    <p>Nintendo Tetris uses a 16-bit Fibonacci <a href="http://en.wikipedia.org/wiki/Linear_feedback_shift_register">linear feedback shift register</a> (LFSR) as a pseudorandom number generator (PRNG).  The 16-bit value is stored big-endian at <span class="code">$0017</span>–<span class="code">$0018</span>.  It is seeded to <span class="code">$8988</span>, an arbitrary number.</p>
    <div class="centered"><div class="source"><pre>80BC: LDX #$89
80BE: STX $0017    
80C0: DEX
80C1: STX $0018</pre></div></div>
    <p>Each successive pseudorandom number is generated by treating the 
value as a 17-bit number and setting the highest bit to the result of 
XORing bits 1 and 9 together.  Then, the value is right shifted, tossing
 away the lowest bit.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/17.png"></p>
    <p>This process takes place at <span class="code">$AB47</span>.</p>
    <div class="centered"><div class="source"><pre>AB47: LDA $00,X
AB49: AND #$02
AB4B: STA $0000  <span class="comment">; extract bit 1</span>

AB4D: LDA $01,X
AB4F: AND #$02   <span class="comment">; extract bit 9</span>

AB51: EOR $0000
AB53: CLC
AB54: BEQ $AB57   
AB56: SEC        <span class="comment">; XOR bits 1 and 9 together</span>

AB57: ROR $00,X   
AB59: INX        
AB5A: DEY        <span class="comment">; right shift</span>
AB5B: BNE $AB57  <span class="comment">; shifting in the XORed value</span>

AB5D: RTS        <span class="comment">; return</span></pre></div></div> 
    <p>Interestingly, the subroutine above was parameterized such that 
the caller can specify the width of the shift register and where to find
 it in memory.  However, the same parameters are used throughout, 
suggesting that the developers may have borrowed this code from 
somewhere else.</p>
    <p>For anyone who wants to repurpose it further, the algorithm is expressed in Java below.</p>
<div class="centered"><div class="source"><pre><span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">generateNextPseudorandomNumber</span><span style="color: #333333">(</span><span style="color: #333399; font-weight: bold">int</span> value<span style="color: #333333">)</span> <span style="color: #333333">{</span>
  <span style="color: #333399; font-weight: bold">int</span> bit1 <span style="color: #333333">=</span> <span style="color: #333333">(</span>value <span style="color: #333333">&gt;&gt;</span> <span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">)</span> <span style="color: #333333">&amp;</span> <span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">;</span>
  <span style="color: #333399; font-weight: bold">int</span> bit9 <span style="color: #333333">=</span> <span style="color: #333333">(</span>value <span style="color: #333333">&gt;&gt;</span> <span style="color: #0000DD; font-weight: bold">9</span><span style="color: #333333">)</span> <span style="color: #333333">&amp;</span> <span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">;</span>
  <span style="color: #333399; font-weight: bold">int</span> leftmostBit <span style="color: #333333">=</span> bit1 <span style="color: #333333">^</span> bit9<span style="color: #333333">;</span>
  <span style="color: #008800; font-weight: bold">return</span> <span style="color: #333333">(</span>leftmostBit <span style="color: #333333">&lt;&lt;</span> <span style="color: #0000DD; font-weight: bold">15</span><span style="color: #333333">)</span> <span style="color: #333333">|</span> <span style="color: #333333">(</span>value <span style="color: #333333">&gt;&gt;</span> <span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">);</span>
<span style="color: #333333">}</span>
</pre></div></div>
    <p>And, that code can be compacted to a single line.</p>    
<div class="centered"><div class="source"><pre><span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">generateNextPseudorandomNumber</span><span style="color: #333333">(</span><span style="color: #333399; font-weight: bold">int</span> value<span style="color: #333333">)</span> <span style="color: #333333">{</span>
  <span style="color: #008800; font-weight: bold">return</span> <span style="color: #333333">((((</span>value <span style="color: #333333">&gt;&gt;</span> <span style="color: #0000DD; font-weight: bold">9</span><span style="color: #333333">)</span> <span style="color: #333333">&amp;</span> <span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">)</span> <span style="color: #333333">^</span> <span style="color: #333333">((</span>value <span style="color: #333333">&gt;&gt;</span> <span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">)</span> <span style="color: #333333">&amp;</span> <span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">))</span> <span style="color: #333333">&lt;&lt;</span> <span style="color: #0000DD; font-weight: bold">15</span><span style="color: #333333">)</span> <span style="color: #333333">|</span> <span style="color: #333333">(</span>value <span style="color: #333333">&gt;&gt;</span> <span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">);</span>
<span style="color: #333333">}</span>
</pre></div></div>
    <p>This PRNG repeatedly and deterministically generates 32,767 
distinct values, each cycle starting with the original seed.  That is 
one less than half of the possible numbers that can fit in the register 
and any value within that set can serve as the seed.  Many of the values
 outside of the set will produce a chain that eventually leads to a 
number within the set.  However, some starting numbers ultimately 
produce an endless sequence of zeros.</p>
    <p>To gain a rough impression of this PRNG’s performance, I 
generated the visualization below of the values it produces based on a 
suggestion from <a href="http://www.random.org/analysis/">RANDOM.ORG</a>.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/18.png"></p>
    <p>The image was created by treating the PRNG as a generator of 
pseudorandom bits rather than 16-bit integer numbers.  Each pixel was 
colored based on the value in bit 0.  The image is 128×256, covering the
 full sequence.</p>
    <p>Aside from the faint bands across the top and left sides, it has 
the appearance of randomness.  No obvious patterns manifest themselves.</p>
    <p>From power on, the PRNG continually scrambles the register, 
executing at least once per frame.  Not only does this occur on the 
title screen and the menu screens, it happens while Tetriminos are 
falling between spawns.  Meaning, the number of frames that it takes the
 player to position a piece actually affects which piece comes up next. 
 Essentially, the game taps directly into the inherent randomness of the
 human interfaced with it.</p>
    <p>During spawning, the code at <span class="code">$9907</span> executes to pick the type of the new piece.
    </p><div class="centered"><div class="source"><pre>9907: INC $001A    <span class="comment">; spawnCount++;</span>

9909: LDA $0017    <span class="comment">; index = high byte of randomValue;</span>

990B: CLC
990C: ADC $001A    <span class="comment">; index += spawnCount;</span>

990E: AND #$07     <span class="comment">; index &amp;= 7;</span>

9910: CMP #$07     <span class="comment">; if (index == 7) {</span>
9912: BEQ $991C    <span class="comment">;   goto invalidIndex;</span>
                   <span class="comment">; }</span>

9914: TAX          
9915: LDA $994E,X  <span class="comment">; newSpawnID = spawnTable[index];</span>

9918: CMP $0019    <span class="comment">; if (newSpawnID != spawnID) {</span>
991A: BNE $9938    <span class="comment">;   goto useNewSpawnID;</span>
                   <span class="comment">; }</span>

<span class="label">invalidIndex:</span>

991C: LDX #$17
991E: LDY #$02
9920: JSR $AB47    <span class="comment">; randomValue = generateNextPseudorandomNumber(randomValue);</span>

9923: LDA $0017    <span class="comment">; index = high byte of randomValue;</span>

9925: AND #$07     <span class="comment">; index &amp;= 7;</span>

9927: CLC
9928: ADC $0019    <span class="comment">; index += spawnID;</span>

992A: CMP #$07
992C: BCC $9934
992E: SEC
992F: SBC #$07
9931: JMP $992A    <span class="comment">; index %= 7;</span>

9934: TAX
9935: LDA $994E,X  <span class="comment">; newSpawnID = spawnTable[index];</span>

<span class="label">useNewSpawnID:</span>

9938: STA $0019    <span class="comment">; spawnID = newSpawnID;</span>

993A: RTS          <span class="comment">; return;</span></pre></div></div>  
    <p>The program maintains a count at <span class="code">$001A</span> 
of the number of pieces spawned since power on.  It is incremented by 
the first line of the subroutine and because it is a 1-byte counter, it 
loops back to 0 every 256 spawns.  Since the counter is not reset 
between games, prior play history actually contributes to the piece 
selection process.  This is another way that the game takes advantage of
 the player for a source of randomness.</p>
    <p>The subroutine transforms the high byte of the pseudorandom number (<span class="code">$0017</span>) into Tetrimino type and it uses that as an index into a table located at <span class="code">$994E</span> to convert the type into a spawn orientation ID.</p>
    <div class="centered"><div class="source"><pre>994E: <span class="num">02</span>  <span class="comment">; Td</span>
994F: <span class="num">07</span>  <span class="comment">; Jd</span>
9950: <span class="num">08</span>  <span class="comment">; Zh</span>
9951: <span class="num">0A</span>  <span class="comment">; O</span>
9952: <span class="num">0B</span>  <span class="comment">; Sh</span>
9953: <span class="num">0E</span>  <span class="comment">; Ld</span>
9954: <span class="num">12</span>  <span class="comment">; Ih</span></pre></div></div>
    <p>The first step of the transformation involves adding the spawn 
count to the high byte.  A mask is applied to retain only the lower 3 
bits.  If the result is not 7, then it is a valid Tetrimino type and if 
it is not the same as the previously selected piece, then it is used as 
an index into the spawn table.  Otherwise, the next pseudorandom number 
is generated and a mask is applied to retain the lower 3 bits of the 
high byte before adding the prior spawn orientation ID.  Finally, a 
modulo operation is performed to obtain a valid Tetrimino type, which is
 used as an index into the spawn table.</p>
    <p>Since the processor does not directly support modulo, the 
operator is emulated by repeatedly subtracting 7 until the result is 
less than 7.  Modulo is applied to the sum of the masked high byte and 
the prior spawn orientation ID.  The maximum value of that sum is 25.  
Hence, at most, it requires 3 iterations to reduce that to the remainder
 4.</p>
    <p>At the start of each game, the spawn orientation ID (<span class="code">$0019</span>) is initialized to <span class="code">Tu</span> (<span class="code">$00</span>), a value potentially used at <span class="code">$9928</span> during the first spawn.</p>    
    <p>Using the prior spawn orientation ID in the sum as opposed to the
 prior Tetrimino type introduces a bias because the spawn orientation ID
 values are not evenly distributed.  This is illustrated in the table 
below.</p>
    <table class="table1">   
      <tbody><tr><th class="hidden"><span class="hiddencode">$00</span></th><th><span class="code">$02</span></th><th><span class="code">$07</span></th><th><span class="code">$08</span></th><th><span class="code">$0A</span></th><th><span class="code">$0B</span></th><th><span class="code">$0E</span></th><th><span class="code">$12</span></th></tr>
      <tr><th>0</th><td>2</td><td>0</td><td>1</td><td>3</td><td>4</td><td>0</td><td>4</td></tr>
      <tr><th>1</th><td>3</td><td>1</td><td>2</td><td>4</td><td>5</td><td>1</td><td>5</td></tr>
      <tr><th>2</th><td>4</td><td>2</td><td>3</td><td>5</td><td>6</td><td>2</td><td>6</td></tr>
      <tr><th>3</th><td>5</td><td>3</td><td>4</td><td>6</td><td>0</td><td>3</td><td>0</td></tr>
      <tr><th>4</th><td>6</td><td>4</td><td>5</td><td>0</td><td>1</td><td>4</td><td>1</td></tr>
      <tr><th>5</th><td>0</td><td>5</td><td>6</td><td>1</td><td>2</td><td>5</td><td>2</td></tr>
      <tr><th>6</th><td>1</td><td>6</td><td>0</td><td>2</td><td>3</td><td>6</td><td>3</td></tr>
      <tr><th>7</th><td>2</td><td>0</td><td>1</td><td>3</td><td>4</td><td>0</td><td>4</td></tr>      
    </tbody></table>
    <p>Each cell contains a Tetrimino type produced by adding a spawn 
orientation ID (column) to a 3-bit value (row) and then applying modulo 7
 to the sum.  Each row contains duplicates because <span class="code">$07</span> and <span class="code">$0E</span> are both evenly divisible by 7 and <span class="code">$0B</span> and <span class="code">$12</span> have a common remainder.  Rows 0 and 7 are the same because they are 7 apart.</p>
    <p>There are 56 possible input combinations and if the resultant 
Tetrimino types were evenly distributed, the expectation is that in the 
table above each type should appear exactly 8 times.  But, as shown 
below, that is not the case.</p>
    <table class="table1">
      <tbody><tr><th>Type</th><th>Frequency</th></tr>
      <tr><td>T</td><td>9</td></tr>
      <tr><td>J</td><td>8</td></tr>
      <tr><td>Z</td><td>8</td></tr>
      <tr><td>O</td><td>8</td></tr>
      <tr><td>S</td><td>9</td></tr>
      <tr><td>L</td><td>7</td></tr>
      <tr><td>I</td><td>7</td></tr>
    </tbody></table>
    <p>T and S appear more frequently and L and I less frequently.  But,
 the biased code that uses the prior spawn orientation ID is not 
executed every time that the subroutine is called.</p>
    <p>Assume that the PRNG actually produces a sequence of uniformly 
distributed statistically independent values.  That is actually a fair 
assumption considering how the game attempts to appropriate randomness 
from the human player.  Adding the spawn count at <span class="code">$990C</span> will not affect the distribution because the count increases uniformly between calls.  The application of a bit mask at <span class="code">$990E</span> is equivalent to applying modulo 8, which also does not affect the distribution.  Consequentially, the check at <span class="code">$9910</span> jumps to <span class="code">invalidIndex</span> 1/8 of the time.  And, the chance of arriving at the check at <span class="code">$9918</span>
 that compares the newly selected piece against the prior piece is 7/8 
where the probability of a match is 1/7.  This means that there is 
additional chance of <span class="nowrap">7/8 × 1/7 = 1/8</span> of it ending up at <span class="code">invalidIndex</span>.  Overall, there is a 25% chance of using the biased code and a 75% chance of using code that picks Tetriminos uniformly.</p>    
    <p>In a set of 224 spawned Tetriminos, the mathematical expectation 
is 32 instances of each type.  But, the code will actually produce the 
following distribution.</p>
    <table class="table1">
      <tbody><tr><th>Type</th><th>Frequency</th></tr>
      <tr><td>T</td><td>33</td></tr>
      <tr><td>J</td><td>32</td></tr>
      <tr><td>Z</td><td>32</td></tr>
      <tr><td>O</td><td>32</td></tr>
      <tr><td>S</td><td>33</td></tr>
      <tr><td>L</td><td>31</td></tr>
      <tr><td>I</td><td>31</td></tr>
    </tbody></table>
    <p>Meaning, in clearing 90 rows and reaching level 9, the player 
will encounter one additional T and S and one fewer L and I than 
statistically expected.</p>
    <p>Tetriminos are picked with the following probabilities.</p>
    <table class="table1">
      <tbody><tr><th>Type</th><th>Probability</th></tr>
      <tr><td>T</td><td>14.73%</td></tr>
      <tr><td>J</td><td>14.29%</td></tr>
      <tr><td>Z</td><td>14.29%</td></tr>
      <tr><td>O</td><td>14.29%</td></tr>
      <tr><td>S</td><td>14.73%</td></tr>
      <tr><td>L</td><td>13.84%</td></tr>
      <tr><td>I</td><td>13.84%</td></tr>
    </tbody></table>  
    <p>Apparently, at least in Nintendo Tetris, there is some truth 
behind the notation that the I Tetrimino never shows up when you need 
it.</p>
    
    <h3><a id="Shifting_Tetriminos">Shifting Tetriminos</a></h3>
    <p>Nintendo Tetris provides Delayed Auto Shift (DAS).  Pressing Left
 or Right immediately shifts the active Tetrimino 1 cell horizontally.  
While, holding down one of those direction buttons causes the game to 
automatically shift the piece every 6 frames after an initial delay of 
16 frames.</p>
    <p>This style of horizontal movement is controlled by code at <span class="code">$89AE</span>.</p>
    <div class="centered"><div class="source"><pre>89AE: LDA $0040  
89B0: STA $00AE  <span class="comment">; originalX = tetriminoX;</span>

89B2: LDA $00B6  <span class="comment">; if (pressing down) {</span> 
89B4: AND #$04   <span class="comment">;   return;</span>
89B6: BNE $8A09  <span class="comment">; }</span> 

89B8: LDA $00B5  <span class="comment">; if (just pressed left/right) {</span>
89BA: AND #$03   <span class="comment">;   goto resetAutorepeatX;</span>
89BC: BNE $89D3  <span class="comment">; }</span>

89BE: LDA $00B6  <span class="comment">; if (not pressing left/right) {</span>
89C0: AND #$03   <span class="comment">;   return;</span>  
89C2: BEQ $8A09  <span class="comment">; }</span>

89C4: INC $0046  <span class="comment">; autorepeatX++;</span>
89C6: LDA $0046  <span class="comment">; if (autorepeatX &lt; 16) {</span>
89C8: CMP #$10   <span class="comment">;   return;</span> 
89CA: BMI $8A09  <span class="comment">; }</span>
 
89CC: LDA #$0A
89CE: STA $0046  <span class="comment">; autorepeatX = 10;</span>
89D0: JMP $89D7  <span class="comment">; goto buttonHeldDown;</span>       

<span class="label">resetAutorepeatX:</span>

89D3: LDA #$00
89D5: STA $0046  <span class="comment">; autorepeatX = 0;</span>

<span class="label">buttonHeldDown:</span>
 
89D7: LDA $00B6  <span class="comment">; if (not pressing right) {</span>
89D9: AND #$01   <span class="comment">;   goto notPressingRight;</span>
89DB: BEQ $89EC  <span class="comment">; }</span>

89DD: INC $0040  <span class="comment">; tetriminoX++;</span>
89DF: JSR $948B  <span class="comment">; if (new position not valid) {</span>
89E2: BNE $8A01  <span class="comment">;   goto restoreX;</span>
                 <span class="comment">; }</span>

89E4: LDA #$03
89E6: STA $06F1  <span class="comment">; play shift sound effect;</span>
89E9: JMP $8A09  <span class="comment">; return;</span>

<span class="label">notPressingRight:</span>

89EC: LDA $00B6  <span class="comment">; if (not pressing left) {</span>
89EE: AND #$02   <span class="comment">;   return;</span>
89F0: BEQ $8A09  <span class="comment">; }</span>

89F2: DEC $0040  <span class="comment">; tetriminoX--;</span>
89F4: JSR $948B  <span class="comment">; if (new position not valid) {</span>
89F7: BNE $8A01  <span class="comment">;   goto restoreX;</span>
                 <span class="comment">; }</span>

89F9: LDA #$03
89FB: STA $06F1  <span class="comment">; play shift sound effect;</span>
89FE: JMP $8A09  <span class="comment">; return;</span>

<span class="label">restoreX:</span>

8A01: LDA $00AE  
8A03: STA $0040  <span class="comment">; tetriminoX = originalX;</span>

8A05: LDA #$10          
8A07: STA $0046  <span class="comment">; autorepeatX = 16;</span>

8A09: RTS        <span class="comment">; return;</span></pre></div></div> 
    <p>Similar to the rotation code, a temporary variable is used to backup the <span class="nowrap">x-coordinate</span> in case the new position turns out to be invalid.</p>
    <p>Also, note that a check prevents shifting the piece while the player is pressing Down.</p>
    
    <h3><a id="Dropping_Tetriminos">Dropping Tetriminos</a></h3>
    <p>The speed at which Tetriminos automatically drop is a function of
 the level.  The speeds are encoded as rendered frames per drop in a 
table located at <span class="code">$898E</span>.  Since the NES runs at 60.0988 frames/sec, the period between drops and the speed can be computed.
    </p><table class="table1">
      <tbody><tr><th>Level</th><th>Frames/drop</th><th>Period (sec/drop)</th><th>Speed (drops/sec)</th></tr>
      <tr><td>0</td><td>48</td><td>.799</td><td>1.25</td></tr>
      <tr><td>1</td><td>43</td><td>.715</td><td>1.40</td></tr>
      <tr><td>2</td><td>38</td><td>.632</td><td>1.58</td></tr>
      <tr><td>3</td><td>33</td><td>.549</td><td>1.82</td></tr>
      <tr><td>4</td><td>28</td><td>.466</td><td>2.15</td></tr>
      <tr><td>5</td><td>23</td><td>.383</td><td>2.61</td></tr>
      <tr><td>6</td><td>18</td><td>.300</td><td>3.34</td></tr>
      <tr><td>7</td><td>13</td><td>.216</td><td>4.62</td></tr>
      <tr><td>8</td><td>8</td><td>.133</td><td>7.51</td></tr>
      <tr><td>9</td><td>6</td><td>.100</td><td>10.02</td></tr>
      <tr><td>10–12</td><td>5</td><td>.083</td><td>12.02</td></tr>
      <tr><td>13–15</td><td>4</td><td>.067</td><td>15.05</td></tr>
      <tr><td>16–18</td><td>3</td><td>.050</td><td>20.03</td></tr>
      <tr><td>19–28</td><td>2</td><td>.033</td><td>30.05</td></tr>
      <tr><td>29+</td><td>1</td><td>.017</td><td>60.10</td></tr>
    </tbody></table>
    <p>The table only contains 30 entries.  Above level 29, the frames per drop is locked at 1.</p>
    <p>An integer number of frames per drop is not a very granular way 
of representing speed.  As shown in the chart below, speed increases 
exponentially with level.  In fact, level 29 is twice as fast as level 
28.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/15.png"></p>
    <p>At 1 frame/drop, the player has at most 1/3 of a second to 
position the piece once it starts moving.  At that drop speed, the DAS 
does not permit the piece to reach the edges of the playfield before 
lock, quickly ending the game for most humans.  However, some players, 
most notably <a href="http://en.wikipedia.org/wiki/Thor_Aackerlund">Thor Aackerlund</a>, overcome the DAS by rapidly vibrating the <span class="nowrap">D-pad</span>.
  From the shift code above, as long as the horizontal direction button 
is released exactly every other frame, it is possible to shift the 
Tetrimino at half the rate that it drops on levels 29 and above.  That 
is the theoretical maximum, but any vibration of the thumb above 3.75 
presses/sec will overcome the initial 16 frame delay.</p>
    <p>If a timed automatic drop and a player controlled soft drop 
(pressing Down) coincide within the same frame, the effect is not 
cumulative.  Either or both of those events will cause the piece to 
advance downward exactly one cell in that frame.</p>
    <p>The logic that controls the drop is located at <span class="code">$8914</span>.</p>
    <div class="centered"><div class="source"><pre>8914: LDA $004E    <span class="comment">; if (autorepeatY &gt; 0) {</span>
8916: BPL $8922    <span class="comment">;   goto autorepeating;</span>
                   <span class="comment">; } else if (autorepeatY == 0) {</span>
                   <span class="comment">;   goto playing;</span>
                   <span class="comment">; }</span>

                   <span class="comment">; game just started</span>
                   <span class="comment">; initial Tetrimino hanging at spawn point</span> 

8918: LDA $00B5    <span class="comment">; if (not just pressed down) {</span> 
891A: AND #$04     <span class="comment">;   goto incrementAutorepeatY;</span>
891C: BEQ $8989    <span class="comment">; }</span>

                   <span class="comment">; player just pressed down ending startup delay</span>

891E: LDA #$00     
8920: STA $004E    <span class="comment">; autorepeatY = 0;</span>
8922: BNE $8939    

<span class="label">playing:</span>

8924: LDA $00B6    <span class="comment">; if (left or right pressed) {</span>
8926: AND #$03     <span class="comment">;   goto lookupDropSpeed;</span>
8928: BNE $8973    <span class="comment">; }</span>

                   <span class="comment">; left/right not pressed</span>

892A: LDA $00B5    
892C: AND #$0F     <span class="comment">; if (not just pressed only down) {</span>
892E: CMP #$04     <span class="comment">;   goto lookupDropSpeed;</span>
8930: BNE $8973    <span class="comment">; }</span>

                   <span class="comment">; player exclusively just presssed down</span>

8932: LDA #$01
8934: STA $004E    <span class="comment">; autorepeatY = 1;</span>

8936: JMP $8973    <span class="comment">; goto lookupDropSpeed;</span>

<span class="label">autorepeating:</span>

8939: LDA $00B6   
893B: AND #$0F     <span class="comment">; if (down pressed and not left/right) {</span>
893D: CMP #$04     <span class="comment">;   goto downPressed;</span>
893F: BEQ $894A    <span class="comment">; }</span>  

                   <span class="comment">; down released</span>

8941: LDA #$00    
8943: STA $004E    <span class="comment">; autorepeatY = 0</span>
8945: STA $004F    <span class="comment">; holdDownPoints = 0</span>
8947: JMP $8973    <span class="comment">; goto lookupDropSpeed;</span>

<span class="label">downPressed:</span>

894A: INC $004E    <span class="comment">; autorepeatY++;</span>
894C: LDA $004E
894E: CMP #$03     <span class="comment">; if (autorepeatY &lt; 3) {</span>
8950: BCC $8973    <span class="comment">;   goto lookupDropSpeed;</span>
                   <span class="comment">; }</span>

8952: LDA #$01   
8954: STA $004E    <span class="comment">; autorepeatY = 1;</span>

8956: INC $004F    <span class="comment">; holdDownPoints++;</span>

<span class="label">drop:</span>

8958: LDA #$00     
895A: STA $0045    <span class="comment">; fallTimer = 0;</span>

895C: LDA $0041   
895E: STA $00AE    <span class="comment">; originalY = tetriminoY;</span>

8960: INC $0041    <span class="comment">; tetriminoY++;</span>
8962: JSR $948B    <span class="comment">; if (new position valid) {</span>
8965: BEQ $8972    <span class="comment">;   return;</span>
                   <span class="comment">; }</span>

                   <span class="comment">; the piece is locked</span>

8967: LDA $00AE  
8969: STA $0041    <span class="comment">; tetriminoY = originalY;</span>

896B: LDA #$02   
896D: STA $0048    <span class="comment">; playState = UPDATE_PLAYFIELD;</span>
896F: JSR $9CAF    <span class="comment">; updatePlayfield();</span>
 
8972: RTS          <span class="comment">; return;</span>

<span class="label">lookupDropSpeed:</span>

8973: LDA #$01     <span class="comment">; tempSpeed = 1;</span>

8975: LDX $0044    <span class="comment">; if (level &gt;= 29) {</span>
8977: CPX #$1D     <span class="comment">;   goto noTableLookup;</span>
8979: BCS $897E    <span class="comment">; }</span>
  
897B: LDA $<span class="num">898E</span>,X  <span class="comment">; tempSpeed = framesPerDropTable[level];</span>
 
<span class="label">noTableLookup:</span>

897E: STA $00AF    <span class="comment">; dropSpeed = tempSpeed;</span>

8980: LDA $0045    <span class="comment">; if (fallTimer &gt;= dropSpeed) {</span>
8982: CMP $00AF    <span class="comment">;   goto drop;</span>
8984: BPL $8958    <span class="comment">; }</span>

8986: JMP $8972    <span class="comment">; return;</span>

<span class="label">incrementAutorepeatY:</span>

8989: INC $004E    <span class="comment">; autorepeatY++;</span>
898B: JMP $8972    <span class="comment">; return;</span></pre></div></div>    
    <p>The frames-per-drop table is referenced at label <span class="code">lookupDropSpeed</span>.  As mentioned above, the speed defaults to 1 drop/frame when the level is 29 or higher.</p>    
    <p>The <span class="code">fallTimer</span> (<span class="code">$0045</span>) triggers a drop when it reaches the <span class="code">dropSpeed</span> (<span class="code">$00AF</span>).  The <span class="code">fallTimer</span> is incremented at <span class="code">$8892</span>, outside of the snippet above.  It is reset to 0 upon an automatic or soft drop.</p>
    <p>The variable <span class="code">autorepeatY</span> (<span class="code">$004E</span>) is initialized to <span class="code">$0A</span> (at <span class="code">$8739</span>),
 which is interpreted as −96.  The condition at the very top causes an 
opening entry delay.  The very first Tetrimino remains suspended at the 
spawn location until <span class="code">autorepeatY</span> is incremented to 0, which takes 1.6 seconds.  However, pressing down during this phase immediately sets <span class="code">autorepeatY</span> to 0.  Interestingly, it is possible to shift and rotate during the opening entry delay without cancelling it.</p>    
    <p><span class="code">autorepeatY</span> is incremented if Down is held.  When it reaches 3, a soft drop happens and <span class="code">autorepeatY</span> is set to 1.  Consequentially, the initial soft drop requires 3 frames, but from there it repeats every other frame.</p>
    <p>In addition, <span class="code">autorepeatY</span> will advance from 0 to 1 only if the game detects that the player just pressed Down (via <span class="code">$00B5</span>) as opposed to detecting that Down is held.  This is significant because <span class="code">autorepeatY</span> is reset to 0 when a Tetrimino is spawned (at <span class="code">$98E8</span>),
 providing an important feature: if the player soft drops a piece into 
lock and he inadvertently continues to keep Down held through the 
subsequent spawn, which is a common occurrence at higher levels, it will
 not cause the new piece to soft drop.  To convey that intension, the 
player must release Down before subsequently reusing it.</p>
    <p>Soft drops can potentially increase the score.  <span class="code">holdDownPoints</span> (<span class="code">$004F</span>)
 is incremented for each drop, but it is reset to 0 when Down is 
released.  As a result, to gain points, the Tetrimino needs to be soft 
dropped into lock.  Any brief soft drop that might occur prior along the
 way in positioning the piece will not contribute to the score.  The 
score is updated at <span class="code">$9BFE</span> and <span class="code">holdDownPoints</span> is reset to 0 shortly afterward at <span class="code">$9C2F</span>.</p>
    <p>A check that prevents the player from soft dropping while 
shifting complicates gaining points.  It means that the final move must 
be down.</p>
    <p>When a drop occurs, <span class="code">tetriminoY</span> (<span class="code">$0041</span>) is backed up to <span class="code">originalY</span> (<span class="code">$00AE</span>).  If the new position created by incrementing <span class="code">tetriminoY</span>
 turns out to be invalid (it either pushed through the floor of the 
playfield or it overlapped other existing squares), then the Tetrimino 
was actually supported in the prior position.  In that event, <span class="code">tetriminoY</span>
 is restored and the piece is considered locked.  This means that the 
lock delay—the maximum number of frames that a Tetrimino waits while 
supported before locking—is equal to the drop delay.</p>
    <p>Nintendo Tetris does not support hard drops.</p>
    
    <h3><a id="Slides_and_Spins">Slides and Spins</a></h3>
    <p>The Nintendo Tetris Instruction Booklet contains an illustrated lesson on how to slide:</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/62.png"></p>
    <p>A slide involves shifting across the surface of other pieces or 
across the floor of the playfield usually with the intension of 
positioning a piece under an overhang.  It is possible to slide until 
the fall timer reaches the drop speed at which point the piece will 
lock.  Below is an animated example.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/58.gif"></p>
    <p>On the other hand, spins rotate pieces into spaces unreachable by any other means (see below).</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/59.gif"></p>
    <p>Like slides, spins would not be possible without lock delay.  
But, spins also exploit the way that the game manipulates pieces.  Prior
 to moving or rotating a piece, the game verifies that all of the 
Tetrimino's squares when repositioned are situated on empty cells within
 the bounds of the playfield.  That check, which is listed below, does 
not inhibit rotation through adjacent solid blocks.</p>
        <div class="centered"><div class="source"><pre>948B: LDA $0041     
948D: ASL           
948E: STA $00A8
9490: ASL
9491: ASL           
9492: CLC
9493: ADC $00A8
9495: ADC $0040
9497: STA $00A8 

9499: LDA $0042     
949B: ASL
949C: ASL
949D: STA $00A9
949F: ASL           
94A0: CLC
94A1: ADC $00A9     
94A3: TAX          <span class="comment">; index = 12 * orientationID;</span>
94A4: LDY #$00

94A6: LDA #$04
94A8: STA $00AA    <span class="comment">; for(i = 0; i &lt; 4; i++) {</span>

94AA: LDA $8A9C,X  <span class="comment">;   squareY = orientationTable[index];</span>
94AD: CLC
94AE: ADC $0041    <span class="comment">;   cellY = squareY + tetriminoY;</span> 
94B0: ADC #$02     <span class="comment">;   if (cellY &lt; -2 || cellY &gt;= 20) {</span>
94B2: CMP #$16     <span class="comment">;     return false;</span>
94B4: BCS $94E9    <span class="comment">;   }</span>

94B6: LDA $8A9C,X
94B9: ASL
94BA: STA $00AB
94BC: ASL
94BD: ASL
94BE: CLC
94BF: ADC $00AB
94C1: CLC
94C2: ADC $00A8
94C4: STA $00AD 

94C6: INX
94C7: INX          <span class="comment">;   index += 2;</span>

94C8: LDA $8A9C,X  <span class="comment">;   squareX = orientationTable[index];</span>
94CB: CLC
94CC: ADC $00AD    
94CE: TAY          <span class="comment">;   cellX = squareX + tetriminoX;</span>
94CF: LDA ($B8),Y  <span class="comment">;   if (playfield[10 * cellY + cellX] != EMPTY_TILE) {</span>
94D1: CMP #$EF     <span class="comment">;     return false;</span>
94D3: BCC $94E9    <span class="comment">;   }</span>

94D5: LDA $8A9C,X
94D8: CLC          
94D9: ADC $0040    <span class="comment">;   if (cellX &lt; 0 || cellX &gt;= 10) {</span> 
94DB: CMP #$0A     <span class="comment">;     return false;</span>
94DD: BCS $94E9    <span class="comment">;   }</span>

94DF: INX          <span class="comment">;   index++;</span>
94E0: DEC $00AA    
94E2: BNE $94AA    <span class="comment">; }</span>

94E4: LDA #$00     
94E6: STA $00A8    
94E8: RTS          <span class="comment">; return true;</span>

94E9: LDA #$FF     
94EB: STA $00A8    
94ED: RTS</pre></div></div>
    <p>As discussed in an <a href="#Representing_Tetriminos">earlier section</a>,
 each row of the orientation table contains 12 bytes; hence, the index 
into the table is computed by multiplying the active Tetrimino’s 
orientation ID by 12.  As shown below, all of the multiplications in the
 subroutine are performed via shifts and additions.</p>
    <div class="centered"><div class="source"><pre>index = (orientationID &lt;&lt; 3) + (orientationID &lt;&lt; 2);  <span class="comment">// index = 8 * orientationID + 4 * orientationID;</span>
        
(cellY &lt;&lt; 3) + (cellY &lt;&lt; 1)  <span class="comment">// 8 * cellY + 2 * cellY</span></pre></div></div>
    <p>Each iteration of the loop offsets the Tetrimino’s position by 
the relative coordinates of one of the squares from the orientation 
table to obtain the corresponding playfield cell location.  Then, it 
verifies that the cell coordinates are within the bounds of the 
playfield and that the cell itself is empty.</p>
    <p>The comments below better reflect the way the row range check is performed.</p>
    <div class="centered"><div class="source"><pre>94AA: LDA $8A9C,X  <span class="comment">;   squareY = orientationTable[index];</span>
94AD: CLC
94AE: ADC $0041    <span class="comment">;   cellY = squareY + tetriminoY;</span> 
94B0: ADC #$02     <span class="comment">;   if (cellY + 2 &gt;= 22) {</span>
94B2: CMP #$16     <span class="comment">;     return false;</span>
94B4: BCS $94E9    <span class="comment">;   }</span></pre></div></div>
    <p>In addition to cells of the visible rows, the code treats the 
cells of the 2 hidden rows above the playfield as legal square positions
 without using a compound condition.  This works because in <a href="http://en.wikipedia.org/wiki/Two%27s_complement">two's-complement</a>, negative numbers represented by single-byte variables are equivalent to values above 127.  In this case, the minimum value of <span class="code">cellY</span> is −2, which is stored as <span class="code">$FE</span> (254 in decimal).</p>                   
    <p>The playfield index is sum of <span class="code">cellY</span> multiplied by 10 and <span class="code">cellX</span>.  However, when <span class="code">cellY</span> is −1 (<span class="code">$FF</span> = 255) or −2 (<span class="code">$FE</span> = 254), the product yields −10 (<span class="code">$F6</span> = 246) and −20 (<span class="code">$EC</span> = 236) respectively.  When in range, <span class="code">cellX</span>
 can be as large as 9, producing a maximum index of 246 + 9 = 255, well 
past the end of the playfield.  However, the game initializes <span class="code">$0400</span>–<span class="code">$04FF</span> to <span class="code">$EF</span> (the empty tile) providing 56 extra bytes of padding.</p>
    <p>Oddly, the <span class="code">cellX</span> range check is 
performed after the playfield cell is examined.  But, it will function 
correctly in either order.  The range check also avoids a compound 
condition as denoted by the revised comments below.</p>
    <div class="centered"><div class="source"><pre>94D5: LDA $8A9C,X
94D8: CLC          
94D9: ADC $0040    <span class="comment">;   if (cellX &gt;= 10) {</span> 
94DB: CMP #$0A     <span class="comment">;     return false;</span>
94DD: BCS $94E9    <span class="comment">;   }</span></pre></div></div>
    <p>Further examples of spins made possible by the way this code validates positions appear below.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/60.gif"></p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/56.gif"></p>
    <p>As shown below, it is also possible to slide into a spin.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/55.gif"></p>
    <p>The AI takes advantage of the full range of motion available in Nintendo Tetris including slides and spins.</p>
    
    <h3><a id="Level_30_and_Beyond">Level 30 and Beyond</a></h3>
    <p>After reaching level 30, the level appears to reset to zero as shown below.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/11.png"></p>
    <p>But, level 31 reveals that something different is going on:</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/13.png"></p> 
    <p>The displayed level values are located in a table at <span class="code">$96B8</span>.
    </p><div class="centered"><div class="source"><pre>96B8: <span class="num">00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29</span></pre></div></div>
    <p>As illustrated below, the pattern table is organized such that tiles <span class="code">$00</span> to <span class="code">$0F</span> are the glyphs for <span class="code">0</span> to <span class="code">F</span>.
  This means that displaying a digit of a number, decimal or 
hexadecimal, involves using that digit value directly as the index into 
the pattern table.  In this case, the level values are stored as 
binary-coded decimal (BCD); each nibble of each byte in the sequence is a
 tile value.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/4.png"></p>
    <p>Unfortunately, the game designers apparently assumed that no one 
would get past level 29 and consequentially, they decided to put only 30
 entries into the table.  The strange displayed values are the various 
bytes beyond.  Only a single byte (at <span class="code">$0044</span>) is used for level number, causing the game to slowly cycle through the 256 values shown below.</p>
    <table class="table1">
      <tbody><tr><th class="hidden"><span class="hiddencode">00</span></th><th><span class="code">0</span></th><th><span class="code">1</span></th><th><span class="code">2</span></th><th><span class="code">3</span></th><th><span class="code">4</span></th><th><span class="code">5</span></th><th><span class="code">6</span></th><th><span class="code">7</span></th><th><span class="code">8</span></th><th><span class="code">9</span></th><th><span class="code">A</span></th><th><span class="code">B</span></th><th><span class="code">C</span></th><th><span class="code">D</span></th><th><span class="code">E</span></th><th><span class="code">F</span></th></tr>
      <tr><th><span class="code">0</span></th><td><span class="code">00</span></td><td><span class="code">01</span></td><td><span class="code">02</span></td><td><span class="code">03</span></td><td><span class="code">04</span></td><td><span class="code">05</span></td><td><span class="code">06</span></td><td><span class="code">07</span></td><td><span class="code">08</span></td><td><span class="code">09</span></td><td><span class="code">10</span></td><td><span class="code">11</span></td><td><span class="code">12</span></td><td><span class="code">13</span></td><td><span class="code">14</span></td><td><span class="code">15</span></td></tr>
      <tr><th><span class="code">1</span></th><td><span class="code">16</span></td><td><span class="code">17</span></td><td><span class="code">18</span></td><td><span class="code">19</span></td><td><span class="code">20</span></td><td><span class="code">21</span></td><td><span class="code">22</span></td><td><span class="code">23</span></td><td><span class="code">24</span></td><td><span class="code">25</span></td><td><span class="code">26</span></td><td><span class="code">27</span></td><td><span class="code">28</span></td><td><span class="code">29</span></td><td><span class="code">00</span></td><td><span class="code">0A</span></td></tr>
      <tr><th><span class="code">2</span></th><td><span class="code">14</span></td><td><span class="code">1E</span></td><td><span class="code">28</span></td><td><span class="code">32</span></td><td><span class="code">3C</span></td><td><span class="code">46</span></td><td><span class="code">50</span></td><td><span class="code">5A</span></td><td><span class="code">64</span></td><td><span class="code">6E</span></td><td><span class="code">78</span></td><td><span class="code">82</span></td><td><span class="code">8C</span></td><td><span class="code">96</span></td><td><span class="code">A0</span></td><td><span class="code">AA</span></td></tr>
      <tr><th><span class="code">3</span></th><td><span class="code">B4</span></td><td><span class="code">BE</span></td><td><span class="code">C6</span></td><td><span class="code">20</span></td><td><span class="code">E6</span></td><td><span class="code">20</span></td><td><span class="code">06</span></td><td><span class="code">21</span></td><td><span class="code">26</span></td><td><span class="code">21</span></td><td><span class="code">46</span></td><td><span class="code">21</span></td><td><span class="code">66</span></td><td><span class="code">21</span></td><td><span class="code">86</span></td><td><span class="code">21</span></td></tr>
      <tr><th><span class="code">4</span></th><td><span class="code">A6</span></td><td><span class="code">21</span></td><td><span class="code">C6</span></td><td><span class="code">21</span></td><td><span class="code">E6</span></td><td><span class="code">21</span></td><td><span class="code">06</span></td><td><span class="code">22</span></td><td><span class="code">26</span></td><td><span class="code">22</span></td><td><span class="code">46</span></td><td><span class="code">22</span></td><td><span class="code">66</span></td><td><span class="code">22</span></td><td><span class="code">86</span></td><td><span class="code">22</span></td></tr>
      <tr><th><span class="code">5</span></th><td><span class="code">A6</span></td><td><span class="code">22</span></td><td><span class="code">C6</span></td><td><span class="code">22</span></td><td><span class="code">E6</span></td><td><span class="code">22</span></td><td><span class="code">06</span></td><td><span class="code">23</span></td><td><span class="code">26</span></td><td><span class="code">23</span></td><td><span class="code">85</span></td><td><span class="code">A8</span></td><td><span class="code">29</span></td><td><span class="code">F0</span></td><td><span class="code">4A</span></td><td><span class="code">4A</span></td></tr>
      <tr><th><span class="code">6</span></th><td><span class="code">4A</span></td><td><span class="code">4A</span></td><td><span class="code">8D</span></td><td><span class="code">07</span></td><td><span class="code">20</span></td><td><span class="code">A5</span></td><td><span class="code">A8</span></td><td><span class="code">29</span></td><td><span class="code">0F</span></td><td><span class="code">8D</span></td><td><span class="code">07</span></td><td><span class="code">20</span></td><td><span class="code">60</span></td><td><span class="code">A6</span></td><td><span class="code">49</span></td><td><span class="code">E0</span></td></tr>
      <tr><th><span class="code">7</span></th><td><span class="code">15</span></td><td><span class="code">10</span></td><td><span class="code">53</span></td><td><span class="code">BD</span></td><td><span class="code">D6</span></td><td><span class="code">96</span></td><td><span class="code">A8</span></td><td><span class="code">8A</span></td><td><span class="code">0A</span></td><td><span class="code">AA</span></td><td><span class="code">E8</span></td><td><span class="code">BD</span></td><td><span class="code">EA</span></td><td><span class="code">96</span></td><td><span class="code">8D</span></td><td><span class="code">06</span></td></tr>
      <tr><th><span class="code">8</span></th><td><span class="code">20</span></td><td><span class="code">CA</span></td><td><span class="code">A5</span></td><td><span class="code">BE</span></td><td><span class="code">C9</span></td><td><span class="code">01</span></td><td><span class="code">F0</span></td><td><span class="code">1E</span></td><td><span class="code">A5</span></td><td><span class="code">B9</span></td><td><span class="code">C9</span></td><td><span class="code">05</span></td><td><span class="code">F0</span></td><td><span class="code">0C</span></td><td><span class="code">BD</span></td><td><span class="code">EA</span></td></tr>
      <tr><th><span class="code">9</span></th><td><span class="code">96</span></td><td><span class="code">38</span></td><td><span class="code">E9</span></td><td><span class="code">02</span></td><td><span class="code">8D</span></td><td><span class="code">06</span></td><td><span class="code">20</span></td><td><span class="code">4C</span></td><td><span class="code">67</span></td><td><span class="code">97</span></td><td><span class="code">BD</span></td><td><span class="code">EA</span></td><td><span class="code">96</span></td><td><span class="code">18</span></td><td><span class="code">69</span></td><td><span class="code">0C</span></td></tr>
      <tr><th><span class="code">A</span></th><td><span class="code">8D</span></td><td><span class="code">06</span></td><td><span class="code">20</span></td><td><span class="code">4C</span></td><td><span class="code">67</span></td><td><span class="code">97</span></td><td><span class="code">BD</span></td><td><span class="code">EA</span></td><td><span class="code">96</span></td><td><span class="code">18</span></td><td><span class="code">69</span></td><td><span class="code">06</span></td><td><span class="code">8D</span></td><td><span class="code">06</span></td><td><span class="code">20</span></td><td><span class="code">A2</span></td></tr>
      <tr><th><span class="code">B</span></th><td><span class="code">0A</span></td><td><span class="code">B1</span></td><td><span class="code">B8</span></td><td><span class="code">8D</span></td><td><span class="code">07</span></td><td><span class="code">20</span></td><td><span class="code">C8</span></td><td><span class="code">CA</span></td><td><span class="code">D0</span></td><td><span class="code">F7</span></td><td><span class="code">E6</span></td><td><span class="code">49</span></td><td><span class="code">A5</span></td><td><span class="code">49</span></td><td><span class="code">C9</span></td><td><span class="code">14</span></td></tr>
      <tr><th><span class="code">C</span></th><td><span class="code">30</span></td><td><span class="code">04</span></td><td><span class="code">A9</span></td><td><span class="code">20</span></td><td><span class="code">85</span></td><td><span class="code">49</span></td><td><span class="code">60</span></td><td><span class="code">A5</span></td><td><span class="code">B1</span></td><td><span class="code">29</span></td><td><span class="code">03</span></td><td><span class="code">D0</span></td><td><span class="code">78</span></td><td><span class="code">A9</span></td><td><span class="code">00</span></td><td><span class="code">85</span></td></tr>
      <tr><th><span class="code">D</span></th><td><span class="code">AA</span></td><td><span class="code">A6</span></td><td><span class="code">AA</span></td><td><span class="code">B5</span></td><td><span class="code">4A</span></td><td><span class="code">F0</span></td><td><span class="code">5C</span></td><td><span class="code">0A</span></td><td><span class="code">A8</span></td><td><span class="code">B9</span></td><td><span class="code">EA</span></td><td><span class="code">96</span></td><td><span class="code">85</span></td><td><span class="code">A8</span></td><td><span class="code">A5</span></td><td><span class="code">BE</span></td></tr>
      <tr><th><span class="code">E</span></th><td><span class="code">C9</span></td><td><span class="code">01</span></td><td><span class="code">D0</span></td><td><span class="code">0A</span></td><td><span class="code">A5</span></td><td><span class="code">A8</span></td><td><span class="code">18</span></td><td><span class="code">69</span></td><td><span class="code">06</span></td><td><span class="code">85</span></td><td><span class="code">A8</span></td><td><span class="code">4C</span></td><td><span class="code">BD</span></td><td><span class="code">97</span></td><td><span class="code">A5</span></td><td><span class="code">B9</span></td></tr>
      <tr><th><span class="code">F</span></th><td><span class="code">C9</span></td><td><span class="code">04</span></td><td><span class="code">D0</span></td><td><span class="code">0A</span></td><td><span class="code">A5</span></td><td><span class="code">A8</span></td><td><span class="code">38</span></td><td><span class="code">E9</span></td><td><span class="code">02</span></td><td><span class="code">85</span></td><td><span class="code">A8</span></td><td><span class="code">4C</span></td><td><span class="code">BD</span></td><td><span class="code">97</span></td><td><span class="code">A5</span></td><td><span class="code">A8</span></td></tr>
    </tbody></table>    
    
    <p>The first 20 successive values are actually another table that stores the offsets into the playfield for each of the 20 rows.</p>
    <div class="centered"><div class="source"><pre>96D6: <span class="num">00</span> <span class="comment">;   0</span>
96D7: <span class="num">0A</span> <span class="comment">;  10</span>
96D8: <span class="num">14</span> <span class="comment">;  20</span>
96D9: <span class="num">1E</span> <span class="comment">;  30</span>
96DA: <span class="num">28</span> <span class="comment">;  40</span>
96DB: <span class="num">32</span> <span class="comment">;  50</span>
96DC: <span class="num">3C</span> <span class="comment">;  60</span>
96DD: <span class="num">46</span> <span class="comment">;  70</span>
96DE: <span class="num">50</span> <span class="comment">;  80</span>
96DF: <span class="num">5A</span> <span class="comment">;  90</span>
96E0: <span class="num">64</span> <span class="comment">; 100</span>
96E1: <span class="num">6E</span> <span class="comment">; 110</span>
96E2: <span class="num">78</span> <span class="comment">; 120</span>
96E3: <span class="num">82</span> <span class="comment">; 130</span>
96E4: <span class="num">8C</span> <span class="comment">; 140</span>
96E5: <span class="num">96</span> <span class="comment">; 150</span>
96E6: <span class="num">A0</span> <span class="comment">; 160</span>
96E7: <span class="num">AA</span> <span class="comment">; 170</span>
96E8: <span class="num">B4</span> <span class="comment">; 180</span>
96E9: <span class="num">BE</span> <span class="comment">; 190</span></pre></div></div> 
    <p>Since the playfield starts at <span class="code">$0400</span> and each row contains 10 cells, the address of an arbitrary cell is:</p>
    <div class="centered"><div class="source"><pre>$0400 + 10 * y + x</pre></div></div> 
    <p>Considering that the processor does not directly support 
multiplication, that lookup table provides an extremely fast way of 
obtaining the product.</p>
    <div class="centered"><div class="source"><pre>$0400 + [$96D6 + y] + x</pre></div></div> 
    <p>A related table occupies the next 40 bytes.  It contains 20 
addresses, stored little endian, into nametable 0, the region of VRAM 
holding background tile values.  They are pointers to the rows of the 
playfield offset by <span class="code">$06</span>.</p>
    <p>The remaining bytes that produce the displayed level values are instructions.</p>

    <h3><a id="Lines_and_Statistics">Lines and Statistics</a></h3>
    <p>The number of completed lines and the Tetrimino statistics occupy 2 bytes each at the following locations.</p>
    <table class="table1">
      <tbody><tr><th>Addresses</th><th>Count</th></tr>
      <tr><td><span class="code">0050</span>–<span class="code">0051</span></td><td>Lines</td></tr>
      <tr><td><span class="code">03F0</span>–<span class="code">03F1</span></td><td>T</td></tr>
      <tr><td><span class="code">03F2</span>–<span class="code">03F3</span></td><td>J</td></tr>
      <tr><td><span class="code">03F4</span>–<span class="code">03F5</span></td><td>Z</td></tr>
      <tr><td><span class="code">03F6</span>–<span class="code">03F7</span></td><td>O</td></tr>
      <tr><td><span class="code">03F8</span>–<span class="code">03F9</span></td><td>S</td></tr>
      <tr><td><span class="code">03FA</span>–<span class="code">03FB</span></td><td>L</td></tr>
      <tr><td><span class="code">03FC</span>–<span class="code">03FD</span></td><td>I</td></tr>
    </tbody></table>
    <p>The values are essentially stored as little endian 16-bit packed 
BCD.  For example, a line count of 123 is represented below.  The bytes 
appear right-to-left to order the decimal digits.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/21.png"></p>
    <p>However, the game designers assumed that none of the values would
 ever exceed 999.  As such, the display logic properly treats the first 
byte as packed BCD, each nibble serving as a tile value.  But, the 
entire second byte effectively acts the upper decimal digit.  Whenever 
the lower digits rolls over from <span class="code">99</span> to <span class="code">00</span>,
 the second byte is simply incremented.  Ultimately, the second byte 
cycles through all 256 tiles.  Below, you can see this mid-action.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/14.png"></p>
    <p>When a row is cleared, the following code executes to increment the line count.</p>
    <div class="centered"><div class="source"><pre>9BA8: INC $0050  <span class="comment">; increment middle-lowest digit pair</span>
9BAA: LDA $0050  
9BAC: AND #$0F    
9BAE: CMP #$0A   <span class="comment">; if (lowest digit &gt; 9) {</span>
9BB0: BMI $9BC7     
9BB2: LDA $0050   
9BB4: CLC        
9BB5: ADC #$06   <span class="comment">;   set lowest digit to 0, increment middle digit</span>
9BB7: STA $0050   
9BB9: AND #$F0   
9BBB: CMP #$A0   <span class="comment">;   if (middle digit &gt; 9) {</span>
9BBD: BCC $9BC7       
9BBF: LDA $0050     
9BC1: AND #$0F    
9BC3: STA $0050  <span class="comment">;     set middle digit to 0</span>
9BC5: INC $0051  <span class="comment">;     increment highest digit</span>
                 <span class="comment">;   }</span>
                 <span class="comment">; }</span></pre></div></div>    
    <p>Checks are performed on the middle and lowest digits to keep them
 between 0 and 9.  But, the highest digit can be incremented 
indefinitely.</p>
    <p>If the lowest digit is 0 after incrementing the line count, then 
the player just completed a set of 10 rows and the level number needs to
 be incremented as well.  As you can see in the code that follows, an 
additional check is performed before incrementing the level.</p>
    <div class="centered"><div class="source"><pre>9BC7: LDA $0050   
9BC9: AND #$0F    
9BCB: BNE $9BFB  <span class="comment">; if (lowest digit == 0) {</span> 
9BCD: JMP $9BD0     

9BD0: LDA $0051     
9BD2: STA $00A9   
9BD4: LDA $0050   
9BD6: STA $00A8  <span class="comment">;   copy digits from $0050-$0051 to $00A8-$00A9</span>

9BD8: LSR $00A9
9BDA: ROR $00A8
9BDC: LSR $00A9
9BDE: ROR $00A8  
9BE0: LSR $00A9  
9BE2: ROR $00A8  <span class="comment">;   treat $00A8-$00A9 as a 16-bit packed BCD value</span>
9BE4: LSR $00A9  <span class="comment">;   and right-shift it 4 times</span>
9BE6: ROR $00A8  <span class="comment">;   this leaves the highest and middle digits in $00A8</span> 

9BE8: LDA $0044     
9BEA: CMP $00A8  <span class="comment">;   if (level &lt; [$00A8]) {</span>
9BEC: BPL $9BFB        

9BEE: INC $0044  <span class="comment">;     increment level</span>
                 <span class="comment">;   }</span>
                 <span class="comment">; }</span></pre></div></div>  
    <p>The second check is related to the selected starting level.  To advance to some level <span class="math">X</span>, the player must clear <span class="math">10X</span>
 rows regardless of the starting level.  For example, if the player 
starts at level 5, he will remain there until he clears 60 rows, at 
which point he will advance to level 6.  From there, each additional 10 
rows will increment the level number.</p>
    <p>To perform this check, the completed lines value is copied from <span class="code">$0050</span>–<span class="code">$0051</span> to <span class="code">$00A8</span>–<span class="code">$00A9</span>.
  Then, the copy is right-shifted 4 times, which for packed BCD is 
equivalent to dividing by 10.  The lowest decimal digit is discarded and
 the upper and middle decimal digits shift over one position ending up 
as the nibbles of <span class="code">$00A8</span>.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/22.png"></p>    
    <p>However, at <span class="code">$9BEA</span> the level number is directly compared against the packed BCD value in <span class="code">$00A8</span>.
  A table lookup to convert the BCD value to decimal is missing, an 
apparent bug.  For instance, in the image above, the level number would 
be compared against <span class="code">$12</span> (18 in decimal) 
instead of 12.  Consequentially, if the player decided to start at level
 17, the level would actually advance at 120 lines because 18 exceeds 
17.</p>
    <p>The table below depicts the expected number of lines required to 
advance at each starting level against what actually happens due to the 
bug.</p>
    <table class="table3">
      <tbody><tr><th class="side"><span class="nowrap">Starting Level</span></th><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td><td>17</td><td>18</td><td>19</td></tr>
      <tr><th class="side"><span class="nowrap">Expected Lines</span></th><td>10</td><td>20</td><td>30</td><td>40</td><td>50</td><td>60</td><td>70</td><td>80</td><td>90</td><td>100</td><td>110</td><td>120</td><td>130</td><td>140</td><td>150</td><td>160</td><td>170</td><td>180</td><td>190</td><td>200</td></tr>
      <tr><th class="side"><span class="nowrap">Actual Lines</span></th><td>10</td><td>20</td><td>30</td><td>40</td><td>50</td><td>60</td><td>70</td><td>80</td><td>90</td><td>100</td><td>100</td><td>100</td><td>100</td><td>100</td><td>100</td><td>100</td><td>110</td><td>120</td><td>130</td><td>140</td></tr>
    </tbody></table>
    <p>Expected matches actual for starting levels 0–9.  In fact, 
starting level 9 only works coincidentally; 10–15 also advance at 100 
lines because <span class="code">$10</span> is 16 in decimal.  The largest gap between expected and actual is 60 lines.</p>
    <p>I suspect that the bug is related to a late stage design change. 
 Take a look at the menu screen that allows the player to select the 
starting level below.  </p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/19.png"></p>
    <p>There is no indication of how to start beyond level 9.  But, the Nintendo Tetris Instruction Booklet reveals the secret:</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/20.png"></p>
    <p>That hidden feature feels like an afterthought.  It might have 
been introduced very close to the target release date, limiting the 
amount of testing that could be performed.</p>
    <p>The starting line check actually contains a second bug related to
 values going out of range.  The code comments are revised below to 
better convey what is happening at the lower level.</p>
    <div class="centered"><div class="source"><pre>9BE8: LDA $0044     
9BEA: CMP $00A8  <span class="comment">; if (level - [$00A8] &lt; 0) {</span>
9BEC: BPL $9BFB        

9BEE: INC $0044  <span class="comment">;   increment level</span>
                 <span class="comment">; }</span></pre></div></div>   
    <p>The comparison is performed by subtraction and testing the sign 
of the result.  But, a 1-byte signed number is limited to the range −128
 to 127.  If the difference is less than −128, then it wraps around and 
the result is a positive number.  The concept is conveyed in the further
 revised comments below.</p>             
    <div class="centered"><div class="source"><pre>9BE8: LDA $0044  <span class="comment">; difference = level - [$00A8];</span>   
9BEA: CMP $00A8  <span class="comment">; if (difference &lt; 0 &amp;&amp; difference &gt;= -128) {</span>
9BEC: BPL $9BFB        

9BEE: INC $0044  <span class="comment">;   increment level</span>
                 <span class="comment">; }</span></pre></div></div>                  

    <p>In evaluating when the difference ends up in that range, consider
 that the level number wraps around to 0 when it is incremented beyond 
255 and <span class="code">$00A8</span> could potentially contain any value because its upper nibble originates from <span class="code">$0051</span>, which is incremented indefinitely.</p>
    <p>These effects collude together to produce periods where the level
 number erroneously remains constant.  The periods occur at regular 
intervals of 2900 lines starting at 2190 lines and they last for 800 
lines.  For instance, from 2190 (<span class="code">L90</span>) to 2990 (<span class="code">T90</span>), the level remains as <span class="code">$DB</span> (<span class="code">96</span>), as shown below.</p>  
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/16.png"></p>
    <p>The next period happens from 5090 to 5890, the level fixed at <span class="code">$AD</span> (<span class="code">06</span>).  And, during the periods, the color palette also remains the same.</p>
    
    <h3><a id="Coloring_Tetriminos">Coloring Tetriminos</a></h3>
    <p>The Tetrimino tiles are assigned 4 distinct colors in each level.  The colors originate from a table at <span class="code">$984C</span>.  Its entries are reused every 10 levels.</p>
    <div class="centered"><div class="source"><pre>984C: <span class="num">0F 30 21 12</span>  <span class="comment">; level 0</span>
9850: <span class="num">0F 30 29 1A</span>  <span class="comment">; level 1</span>
9854: <span class="num">0F 30 24 14</span>  <span class="comment">; level 2</span>
9858: <span class="num">0F 30 2A 12</span>  <span class="comment">; level 3</span>
985C: <span class="num">0F 30 2B 15</span>  <span class="comment">; level 4</span>
9860: <span class="num">0F 30 22 2B</span>  <span class="comment">; level 5</span>
9864: <span class="num">0F 30 00 16</span>  <span class="comment">; level 6</span>
9868: <span class="num">0F 30 05 13</span>  <span class="comment">; level 7</span>
986C: <span class="num">0F 30 16 12</span>  <span class="comment">; level 8</span>
9870: <span class="num">0F 30 27 16</span>  <span class="comment">; level 9</span></pre></div></div>
    <p>From left-to-right, the columns of that table correspond to the 
black, white, blue and red regions in the image below respectively.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/23.png"></p>
    <p>The values refer to the NES color palette.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/9.png"></p>
    <p>The first 2 colors of every entry are black and white.  However, 
the first color is actually ignored; regardless of its value, it is 
treated as a transparent color through which the solid black background 
is exposed.</p>
    <p>The color table is accessed in a subroutine located at <span class="code">$9808</span>.</p>
    <div class="centered"><div class="source"><pre>9808: LDA $0064     
980A: CMP #$0A      
980C: BMI $9814     
980E: SEC           
980F: SBC #$0A                          
9811: JMP $980A    <span class="comment">; index = levelNumber % 10;</span>
 
9814: ASL          
9815: ASL
9816: TAX          <span class="comment">; index *= 4;</span>

9817: LDA #$00
9819: STA $00A8    <span class="comment">; for(i = 0; i &lt; 32; i += 16) {</span>

981B: LDA #$3F    
981D: STA $2006    
9820: LDA #$08
9822: CLC
9823: ADC $00A8    
9825: STA $2006    <span class="comment">;   palette = $3F00 + i + 8;</span>

9828: LDA $984C,X  
982B: STA $2007    <span class="comment">;   palette[0] = colorTable[index + 0];</span>

982E: LDA $984D,X  
9831: STA $2007    <span class="comment">;   palette[1] = colorTable[index + 1];</span>

9834: LDA $984E,X  
9837: STA $2007    <span class="comment">;   palette[2] = colorTable[index + 2];</span>

983A: LDA $984F,X
983D: STA $2007    <span class="comment">;   palette[3] = colorTable[index + 3];</span>

9840: LDA $00A8
9842: CLC
9843: ADC #$10
9845: STA $00A8    
9847: CMP #$20
9849: BNE $981B    <span class="comment">; }</span>

984B: RTS          <span class="comment">; return;</span></pre></div></div>    
    <p>The index into the color table is based on the level number modulo 10.  The loop copies an entry to the palette tables in VRAM.</p>
    <p>Modulo is emulated by repeatedly subtracting 10 until the result 
is less than 10.  Below, the top of the subroutine is listed with 
revised comments to reflect this.</p>
    <div class="centered"><div class="source"><pre>9808: LDA $0064 <span class="comment">; index = levelNumber;</span>    
980A: CMP #$0A  <span class="comment">; while(index &gt;= 10) {</span>
980C: BMI $9814    
980E: SEC            
980F: SBC #$0A  <span class="comment">;   index -= 10;</span>                      
9811: JMP $980A <span class="comment">; }</span></pre></div></div> 
    <p>However, as discussed in the prior section, comparison involves 
subtracting and branching based on the sign of the difference.  And, a 
1-byte signed number is limited to the range −128 to 127.  The updated 
comments below factor in those ideas.</p>
    <div class="centered"><div class="source"><pre>9808: LDA $0064 <span class="comment">; index = levelNumber;</span> 
                <span class="comment">; difference = index - 10;</span>    
980A: CMP #$0A  <span class="comment">; while(difference &gt;= 0 &amp;&amp; difference &lt;= 127) {</span>
980C: BMI $9814    
980E: SEC       <span class="comment">;   index -= 10;</span>       
980F: SBC #$0A  <span class="comment">;   difference = index - 10;</span>                    
9811: JMP $980A <span class="comment">; }</span></pre></div></div> 
    <p>The comments are simplified further below.</p>
    <div class="centered"><div class="source"><pre>9808: LDA $0064 <span class="comment">; index = levelNumber;</span>                 
980A: CMP #$0A  <span class="comment">; while(index &gt;= 10 &amp;&amp; index &lt;= 137) {</span>
980C: BMI $9814    
980E: SEC              
980F: SBC #$0A  <span class="comment">;   index -= 10;</span>                       
9811: JMP $980A <span class="comment">; }</span></pre></div></div>
    <p>This formulation exposes a bug in the code.  The modulo operation
 is completely bypassed for levels 138 and up.  Instead, the index is 
directly assigned to the level number, providing access to the bytes 
well beyond the end of the color table.  This can even result in nearly 
invisible Tetriminos as shown below.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/12.png"></p> 
    <p>The colors of all 256 levels are depicted below.  The tiles are 
arranged in 10 columns to reflect the cyclic application of the color 
table that breaks down at level 138.  The row and column headers are in 
decimal.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/10.png"></p>  
    <p>After 255, the level number loops back to 0.</p>
    <p>Also, as mentioned in the prior section, some levels will not 
advance until 800 lines are cleared.  The colors remain constant 
throughout those long levels.</p>
    
    <h3><a id="Game_Mode">Game Mode</a></h3>
    <p>The game mode, maintained at <span class="code">$00C0</span>, determines which of the various screens and menus is currently presented to the user.</p>
    <table class="table1">
      <tbody><tr><th>Value</th><th>Description</th></tr>
      <tr><td><span class="code">00</span></td><td style="text-align: left;">Legal Screen</td></tr>
      <tr><td><span class="code">01</span></td><td style="text-align: left;">Title Screen</td></tr>
      <tr><td><span class="code">02</span></td><td style="text-align: left;">Game Type Menu</td></tr>
      <tr><td><span class="code">03</span></td><td style="text-align: left;">Level and Height Menu</td></tr>
      <tr><td><span class="code">04</span></td><td style="text-align: left;">Play / High Score Screen / Ending / Pause</td></tr>
      <tr><td><span class="code">05</span></td><td style="text-align: left;">Demo</td></tr>
    </tbody></table>
    <p>As demonstrated below, the game contains a cleverly written 
subroutine that acts as a switch statement via a little endian jump 
table located directly after the call.</p>
    <div class="centered"><div class="source"><pre>8161: LDA $00C0  
8163: JSR $AC82  <span class="comment">; switch(gameMode) {</span>
8166: <span class="num">00 82</span>      <span class="comment">;   case 0: goto 8200;  // Legal Screen</span>
8168: <span class="num">4F 82</span>      <span class="comment">;   case 1: goto 824F;  // Title Screen</span>
816A: <span class="num">D1 82</span>      <span class="comment">;   case 2: goto 82D1;  // Game Type Menu</span>
816C: <span class="num">D7 83</span>      <span class="comment">;   case 3: goto 83D7;  // Level and Height Menu</span>
816E: <span class="num">5D 81</span>      <span class="comment">;   case 4: goto 815D;  // Play / High Score Screen / Ending / Pause</span>
8170: <span class="num">5D 81</span>      <span class="comment">;   case 5: goto 815D;  // Demo</span>
                 <span class="comment">; }</span></pre></div></div>
    <p>The listing above also reveals the addresses of all the game modes.  Note that play and demo mode use the same code.</p>
    <p>The subroutine never returns.  Instead, the code takes advantage 
of the return address; it normally points to the instruction immediately
 following the jump-to-subroutine call (minus 1 byte), but in this case,
 it points to the jump table.    The return address is popped off the 
stack and stored at <span class="code">$0000</span>–<span class="code">$0001</span>.  With the jump table address captured, the code uses the value in the A register as the index and jumps accordingly.</p>
    <div class="centered"><div class="source"><pre>AC82: ASL           
AC83: TAY           
AC84: INY           

AC85: PLA         
AC86: STA $0000      
AC88: PLA           <span class="comment">; pop return address off of stack</span>
AC89: STA $0001     <span class="comment">; and store it at $0000-$0001</span>

AC8B: LDA ($00),Y   
AC8D: TAX           
AC8E: INY           
AC8F: LDA ($00),Y   
AC91: STA $0001     
AC93: STX $0000     
AC95: JMP ($0000)   <span class="comment">; goto Ath 16-bit address</span>
                    <span class="comment">; in table at [$0000-$0001]</span></pre></div></div>    
    <p>The code is able to take advantage of this switching subroutine 
as long as the indices are all near 0 and there are few or no gaps 
between the possible cases.</p>
    
    <h3><a id="Legal_Screen">Legal Screen</a></h3>
    <p>The game starts up with a screen that displays the legal notice.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/51.png"></p>    
    <p>At the bottom, the screen aptly credits <a href="http://en.wikipedia.org/wiki/Alexey_Pajitnov">Alexey Pazhitnov (Alexéy Pájitnov)</a> for conceiving, designing and programming the original Tetris.  In 1984, while working as a computer engineer at the <a href="http://en.wikipedia.org/wiki/Dorodnitsyn_Computing_Centre">Dorodnitsyn Computing Centre</a>, a leading research institute of the Russian Academy of Sciences in Moscow, he developed the prototype on an <a href="http://en.wikipedia.org/wiki/Electronika_60">Electronika 60</a>, a Soviet clone of the DEC <a href="http://en.wikipedia.org/wiki/PDP-11#LSI-11">LSI-11</a>.  It was designed for green monochrome text mode, using pairs of brackets <span class="code">[]</span> to represent squares.  With the help of 16-year-old high school student <a href="http://vadim.oversigma.com/Tetris.htm">Vadim Gerasimov</a> and computer engineer Dmitry Pavlovsky, a few days after its inception, the prototype was ported to the IBM PC with <a href="http://en.wikipedia.org/wiki/Turbo_Pascal">Turbo Pascal</a>
 under MS DOS.  They collectively improved the game over 2 years 
introducing features such as Tetrimino colors and statistics and more 
importantly timing and graphics code that would make the game run 
consistently on the multitude of PC models and clones.</p>
    <p>Unfortunately, due nature of the Soviet Union at the time, their 
attempts to monetize the game failed and they ultimately decided to 
share the PC version with friends gratis.  From there, Tetris spread 
virally across the country and outward, copied from floppy to floppy.  
However, since the game was developed by employees of a government 
institution, it was owned by the state and in 1987, the organization in 
charge of international trade of electronic technology, <a href="http://en.wikipedia.org/wiki/Elektronorgtechnica">Electronorgtechnica (ELORG)</a> became responsible for licensing the game.  The V/O abbreviation in the legal screen might be short for, "Version Originale".</p>
    <p>A British software company called <a href="http://www.atarihq.com/tsr/special/tetrishist.html">Andromeda</a>
 attempted to secure the rights to Tetris and before completing the 
deal, they sublicensed the game to other vendors, such as the United 
Kingdom computer game publisher <a href="http://en.wikipedia.org/wiki/Mirrorsoft">Mirrorsoft</a>.  Mirrorsoft, in turn, sublicensed it further to <a href="http://en.wikipedia.org/wiki/Tengen_(company)">Tengen</a>,
 a subsidiary of Atari Games.  And, Tengen provided Bullet-Proof 
Software with the rights to develop the game for computers and consoles 
in Japan, resulting in Tetris for Nintendo's <a href="http://en.wikipedia.org/wiki/Famicom">Famicom</a>, the legal screen of which is shown below.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/53.png"></p>
    <p>Interestingly, in that version, high school student Vadim Gerasimov is credited as the original designer and programmer.</p>
    <p>In seeking the handheld rights for the upcoming Game Boy, 
Nintendo ended up using Bullet-Proof Software to successfully broker a 
deal directly with ELORG.  In the process, ELORG revised its contract 
with Andromeda, clarifying that Andromeda acquired computer and arcade 
rights only.  This forced Bullet-Proof Software to pay royalties to 
ELORG for all the Famicom cartridges it sold since the rights they got 
from Tengen were bogus.  But, by appeasing ELORG, it helped Bullet-Proof
 Software to ultimately obtain the worldwide console rights for 
Nintendo.</p>    
    <p>Bullet-Proof Software sublicensed the handheld rights to Nintendo
 and they co-developed Game Boy Tetris as shown in the legal screen 
below.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/52.png"></p>
    <p>With the worldwide console rights, Nintendo developed the version
 of Tetris for the NES discussed in this article.  And, Bullet-Proof 
Software subsequently sublicensed the rights from Nintendo to enable 
them to continue to sell Famicom cartridges in Japan.</p>
    <p>A complex legal battle ensued. Nintendo and Tengen each demanded 
that the other stop production and sale of their version of the game.  
Nintendo ultimately prevailed and hundreds of thousands of <a href="http://en.wikipedia.org/wiki/Tetris_(Atari)">Tengen Tetris</a>
 cartridges still in their boxes were scrapped.  The judgment also 
blocked several other companies like Mirrorsoft from manufacturing a 
console version.</p>
    <p>Pazhitnov never received any royalties from ELORG or the Soviet 
government.  However, in 1991, he moved to the United States and in 
1996, with backing from <a href="http://en.wikipedia.org/wiki/Henk_Rogers">Henk Rogers</a>, owner of Bullet-Proof Software, he cofounded <a href="http://www.tetris.com/">The Tetris Company</a>, enabling him to profit from mobile and modern console versions.</p>
    <p>As intriguing as it is to view the legal screen as a window into 
the humble origin of the game and the intellectual properties rights 
battle that followed, as far as most players are concerned, it is just 
an annoying screen that takes forever to disappear.  The delay is 
established by 2 counters that tick down in succession from 255 to 0.  
The first phase is unskippable, but the second phase can be cut short by
 pressing Start.  As such, the legal screen appears for a minimum of 
4.25 seconds and up to 8.5 seconds.  Though, I imagine that most players
 give up pressing Start during the first interval forcing them to wait 
through the whole thing.</p>
    <p>The timing of the phases, as well as the rest of the game, is 
regulated by a non-maskable interrupt handler that is invoked at the 
start of each vertical blanking interval, the brief period between the 
rendering of television frames.  Meaning, every 16.6393 milliseconds, 
normal program flow is interrupted by the following code.</p>
    <div class="centered"><div class="source"><pre>8005: PHA        
8006: TXA
8007: PHA        
8008: TYA
8009: PHA        <span class="comment">; save A, X, Y</span>

800A: LDA #$00
800C: STA $00B3
800E: JSR $804B  <span class="comment">; render();</span>

8011: DEC $00C3  <span class="comment">; legalScreenCounter1--;</span>

8013: LDA $00C3  
8015: CMP #$FF   <span class="comment">; if (legalScreenCounter1 &lt; 0) {</span>
8017: BNE $801B  <span class="comment">;   legalScreenCounter1 = 0;</span>
8019: INC $00C3  <span class="comment">; }</span>

801B: JSR $AB5E  <span class="comment">; initializeOAM();</span>

801E: LDA $00B1
8020: CLC
8021: ADC #$01
8023: STA $00B1
8025: LDA #$00
8027: ADC $00B2
8029: STA $00B2  <span class="comment">; frameCounter++;</span>

802B: LDX #$17
802D: LDY #$02
802F: JSR $AB47  <span class="comment">; randomValue = generateNextPseudorandomNumber(randomValue);</span>

8032: LDA #$00
8034: STA $00FD
8036: STA $2005  <span class="comment">; scrollX = 0;</span>
8039: STA $00FC
803B: STA $2005  <span class="comment">; scrollY = 0;</span>  

803E: LDA #$01
8040: STA $0033  <span class="comment">; verticalBlankingInterval = true;</span>

8042: JSR $9D51  <span class="comment">; pollControllerButtons();</span>

8045: PLA
8046: TAY
8047: PLA
8048: TAX
8049: PLA        <span class="comment">; restore A, X, Y</span>

804A: RTI        <span class="comment">; resume interrupted task</span></pre></div></div>    
    <p>The handler starts out by pushing the values of the primary 
registers onto the stack and popping them off at the end to avoid 
interfering with the interrupted task.  The call to <span class="code">render()</span>
 updates VRAM, converting memory model representations into something 
that appears on screen.  Next, the handler decrements the first legal 
screen counter if it is greater than zero.  The <span class="code">initializeOAM()</span>
 call performs a step required by the frame generation hardware.  The 
handler continues by incrementing the frame counter, a 16-bit little 
endian value stored at <span class="code">$00B1</span>–<span class="code">$00B2</span>,
 which is used in various places for controlled timing.  After which, 
the next pseudorandom number is generated; as mentioned, this occurs at 
least once per frame regardless of the mode.  At <span class="code">$8040</span>,
 the vertical blanking interval flag is set to indicate that the handler
 just executed.  Finally, the controller buttons are polled; the 
behavior of that subroutine is described further in the Demo section.</p>
    <p>The <span class="code">verticalBlankingInterval</span> flag is used by the subroutine listed below.  It spins until an execution of the interrupt handler occurs.</p>
    <div class="centered"><div class="source"><pre>AA2F: JSR $E000  <span class="comment">; updateAudio();</span>

AA32: LDA #$00
AA34: STA $0033  <span class="comment">; verticalBlankingInterval = false;</span>

AA36: NOP

AA37: LDA $0033  
AA39: BEQ $AA37  <span class="comment">; while(!verticalBlankingInterval) { }</span>

AA3B: LDA #$FF
AA3D: LDX #$02
AA3F: LDY #$02
AA41: JSR $AC6A  <span class="comment">; fill memory page 2 with all $FF's</span>

AA44: RTS        <span class="comment">; return;</span></pre></div></div>
    <p>That blocking subroutine is used by the 2 timing phases of the legal screen, shown below, which run consecutively.</p>
    <div class="centered"><div class="source"><pre>8236: LDA #$FF
8238: JSR $A459

...

A459: STA $00C3  <span class="comment">; legalScreenCounter1 = 255;</span>

A45B: JSR $AA2F  <span class="comment">; do {</span>
A45E: LDA $00C3  <span class="comment">;   waitForVerticalBlankingInterval();</span>
A460: BNE $A45B  <span class="comment">; } while(legalScreenCounter1 &gt; 0);</span>

A462: RTS        <span class="comment">; return;</span></pre></div></div>


    <div class="centered"><div class="source"><pre>823B: LDA #$FF
823D: STA $00A8  <span class="comment">; legalScreenCounter2 = 255;</span>

                 <span class="comment">; do {</span>

823F: LDA $00F5  <span class="comment">;   if (just pressed Start) {</span>
8241: CMP #$10   <span class="comment">;     break;</span>
8243: BEQ $824C  <span class="comment">;   }</span>

8245: JSR $AA2F  <span class="comment">;   waitForVerticalBlankingInterval();</span>

8248: DEC $00A8  <span class="comment">;   legalScreenCounter2--;</span>
824A: BNE $823F  <span class="comment">; } while(legalScreenCounter2 &gt; 0);</span>

824C: INC $00C0  <span class="comment">; gameMode = TITLE_SCREEN;</span></pre></div></div>
    <p>The AI Lua Script bypasses the delay by forcing the counters to 0.</p>

    <h3><a id="Demo">Demo</a></h3>
    <p>The demo presents approximately 80 seconds of pre-recorded 
gameplay.  It takes advantage of the same engine that runs during play 
as opposed to simply displaying a movie file.  Two tables are involved 
in the reproduction.  The first, located at <span class="code">$DF00</span>, stores the following Tetrimino spawn sequence:</p>
    <p><span class="code">T J T S Z J T S Z J S Z L Z J T T S I T O J S Z L Z L I O L Z L I O J T S I T O J</span></p>
    <p>During spawning, the piece is either randomly selected or it is 
pulled from the table depending on the mode.  The switch occurs at <span class="code">$98EB</span>.</p>
    <div class="centered"><div class="source"><pre>98EB: LDA $00C0    
98ED: CMP #$05
98EF: BNE $9903    <span class="comment">; if (gameMode == DEMO) {</span> 

98F1: LDX $00D3   
98F3: INC $00D3       
98F5: LDA $DF00,X  <span class="comment">;   value = demoTetriminoTypeTable[++demoIndex];</span>  

98F8: LSR
98F9: LSR
98FA: LSR
98FB: LSR          
98FC: AND #$07
98FE: TAX          <span class="comment">;   tetriminoType = bits 6,5,4 of value;</span>

98FF: LDA $994E,X     
9902: RTS          <span class="comment">;   return spawnTable[tetriminoType];</span>
                   <span class="comment">; } else {</span>
                   <span class="comment">;   pickRandomTetrimino();</span>
                   <span class="comment">; }</span></pre></div></div> 
<p>Tetrimino type is extracted from bits 6, 5 and 4 of each byte.  Occasionally, this yields a value of <span class="code">$07</span>, an invalid type.  However, the spawn table (<span class="code">$994E</span>) used to convert Tetrimino type into orientation ID is actually sandwiched between 2 related tables:</p>                  
<div class="centered"><div class="source"><pre>993B: <span class="num">00 00 00 00</span>  <span class="comment">; T</span>
993F: <span class="num">01 01 01 01</span>  <span class="comment">; J</span>
9943: <span class="num">02 02</span>        <span class="comment">; Z</span>
9945: <span class="num">03</span>           <span class="comment">; O</span>
9946: <span class="num">04 04</span>        <span class="comment">; S</span>
9948: <span class="num">05 05 05 05</span>  <span class="comment">; L</span>
994C: <span class="num">06 06</span>        <span class="comment">; I</span></pre></div></div>
    <div class="centered"><div class="source"><pre>994E: <span class="num">02</span>  <span class="comment">; Td</span>
994F: <span class="num">07</span>  <span class="comment">; Jd</span>
9950: <span class="num">08</span>  <span class="comment">; Zh</span>
9951: <span class="num">0A</span>  <span class="comment">; O</span>
9952: <span class="num">0B</span>  <span class="comment">; Sh</span>
9953: <span class="num">0E</span>  <span class="comment">; Ld</span>
9954: <span class="num">12</span>  <span class="comment">; Ih</span></pre></div></div>                   
    <div class="centered"><div class="source"><pre>9956: <span class="num">02 02 02 02</span>  <span class="comment">; Td</span>
995A: <span class="num">07 07 07 07</span>  <span class="comment">; Jd</span>
995E: <span class="num">08 08</span>        <span class="comment">; Zh</span>
9960: <span class="num">0A</span>           <span class="comment">; O</span>
9961: <span class="num">0B 0B</span>        <span class="comment">; Sh</span>
9963: <span class="num">0E 0E 0E 0E</span>  <span class="comment">; Ld</span>
9967: <span class="num">12 12</span>        <span class="comment">; Ih</span></pre></div></div>
    <p>The value <span class="code">$07</span> causes it to read past the end of the table into the next one, bearing <span class="code">Td</span> (<span class="code">$02</span>).</p>
    <p>Due to this effect, this scheme can provide an unlimited yet 
reproducible sequence of pseudorandom spawn orientation IDs.  The code 
will function given any arbitrary address to a varying byte sequence 
making it impossible to determine where the table ends.  In fact, the 
sequence at <span class="code">$DF00</span> may actually be part of 
something entirely unrelated especially considering that the purpose of 
the remaining 5 nonzero bits is unclear and that the generated sequence 
appears to contain repetition.</p>
    <p>The index into the table (<span class="code">$00D3</span>) is reset to 0 during demo mode initialization at <span class="code">$872B</span>.</p>
    <p>The second demo table contains a recording of the gamepad buttons
 encoded in pairs of bytes.  The bits of the first byte correspond to 
the asserted buttons.</p>               
    <table class="table2">
      <tbody><tr><th><span class="code">7</span></th><th><span class="code">6</span></th><th><span class="code">5</span></th><th><span class="code">4</span></th><th><span class="code">3</span></th><th><span class="code">2</span></th><th><span class="code">1</span></th><th><span class="code">0</span></th></tr>
      <tr><td>A</td><td>B</td><td>Select</td><td>Start</td><td>Up</td><td>Down</td><td>Left</td><td>Right</td></tr>
    </tbody></table>
    <p>The second byte stores the number of frames that the button combination was applied.</p>
    <p>The table spans <span class="code">$DD00</span>–<span class="code">$DEFF</span>, composed of 256 pairs.  It is accessed by the subroutine at <span class="code">$9D5B</span>.</p>
    <div class="centered"><div class="source"><pre>9D5B: LDA $00D0    <span class="comment">; if (recording mode) {</span>
9D5D: CMP #$FF     <span class="comment">;   goto recording;</span>
9D5F: BEQ $9DB0    <span class="comment">; }</span>

9D61: JSR $AB9D    <span class="comment">; pollController();</span>
9D64: LDA $00F5    <span class="comment">; if (start button pressed) {</span>
9D66: CMP #$10     <span class="comment">;   goto startButtonPressed;</span>
9D68: BEQ $9DA3    <span class="comment">; }</span>

9D6A: LDA $00CF    <span class="comment">; if (repeats == 0) {</span>
9D6C: BEQ $9D73    <span class="comment">;   goto finishedMove;</span>
                   <span class="comment">; } else {</span>
9D6E: DEC $00CF    <span class="comment">;   repeats--;</span>
9D70: JMP $9D9A    <span class="comment">;   goto moveInProgress;</span>
                   <span class="comment">; }</span>

<span class="label">finishedMove:</span>

9D73: LDX #$00
9D75: LDA ($D1,X)
9D77: STA $00A8    <span class="comment">; buttons = demoButtonsTable[index];</span>

9D79: JSR $9DE8    <span class="comment">; index++;</span>

9D7C: LDA $00CE
9D7E: EOR $00A8
9D80: AND $00A8
9D82: STA $00F5    <span class="comment">; setNewlyPressedButtons(difference between heldButtons and buttons);</span>

9D84: LDA $00A8
9D86: STA $00CE    <span class="comment">; heldButtons = buttons;</span>

9D88: LDX #$00     
9D8A: LDA ($D1,X)
9D8C: STA $00CF    <span class="comment">; repeats = demoButtonsTable[index];</span>

9D8E: JSR $9DE8    <span class="comment">; index++;</span>

9D91: LDA $00D2    <span class="comment">; if (reached end of demo table) {</span>
9D93: CMP #$DF     <span class="comment">;   return;</span>
9D95: BEQ $9DA2    <span class="comment">; }</span>

9D97: JMP $9D9E    <span class="comment">; goto holdButtons;</span>

<span class="label">moveInProgress:</span>

9D9A: LDA #$00
9D9C: STA $00F5    <span class="comment">; clearNewlyPressedButtons();</span>

<span class="label">holdButtons:</span>

9D9E: LDA $00CE
9DA0: STA $00F7    <span class="comment">; setHeldButtons(heldButtons);</span>

9DA2: RTS          <span class="comment">; return;</span>

<span class="label">startButtonPressed:</span>

9DA3: LDA #$DD
9DA5: STA $00D2    <span class="comment">; reset index;</span>

9DA7: LDA #$00
9DA9: STA $00B2    <span class="comment">; counter = 0;</span>

9DAB: LDA #$01
9DAD: STA $00C0    <span class="comment">; gameMode = TITLE_SCREEN;</span>

9DAF: RTS          <span class="comment">; return;</span></pre></div></div>
    <p>Since the demo buttons table is 512 bytes long, a 2-byte index is required to access it.  The index is stored little endian at <span class="code">$00D1</span>–<span class="code">$00D2</span>.  It is initialized to the address of the table at <span class="code">$872D</span> and it is incremented via the following code.</p>
    <div class="centered"><div class="source"><pre>                   
9DE8: LDA $00D1
9DEA: CLC        <span class="comment">; increment [$00D1]</span>
9DEB: ADC #$01   <span class="comment">; possibly causing wrap around to 0</span>
9DED: STA $00D1  <span class="comment">; which produces a carry</span>

9DEF: LDA #$00
9DF1: ADC $00D2
9DF3: STA $00D2  <span class="comment">; add carry to [$00D2]</span>

9DF5: RTS        <span class="comment">; return</span></pre></div></div> 
    <p>The programmers actually left in the code for capturing player 
input, providing a glimpse into the development process and making it 
possible to replace the demo with an alternate recording.  Demo 
recording mode is enabled when <span class="code">$00D0</span> is set to <span class="code">$FF</span>.  It triggers the following code designed to write to the demo buttons table.</p>
    <div class="centered"><div class="source"><pre><span class="label">recording:</span>

9DB0: JSR $AB9D    <span class="comment">; pollController();</span>

9DB3: LDA $00C0    <span class="comment">; if (gameMode != DEMO) {</span>
9DB5: CMP #$05     <span class="comment">;   return;</span>
9DB7: BNE $9DE7    <span class="comment">; }</span>

9DB9: LDA $00D0    <span class="comment">; if (not recording mode) {</span>
9DBB: CMP #$FF     <span class="comment">;   return;</span>
9DBD: BNE $9DE7    <span class="comment">; }</span>

9DBF: LDA $00F7    <span class="comment">; if (getHeldButtons() == heldButtons) {</span>
9DC1: CMP $00CE    <span class="comment">;   goto buttonsNotChanged;</span>
9DC3: BEQ $9DE4    <span class="comment">; }</span>

9DC5: LDX #$00
9DC7: LDA $00CE
9DC9: STA ($D1,X)  <span class="comment">; demoButtonsTable[index] = heldButtons;</span>

9DCB: JSR $9DE8    <span class="comment">; index++;</span>

9DCE: LDA $00CF
9DD0: STA ($D1,X)  <span class="comment">; demoButtonsTable[index] = repeats;</span>

9DD2: JSR $9DE8    <span class="comment">; index++;</span>

9DD5: LDA $00D2    <span class="comment">; if (reached end of demo table) {</span>
9DD7: CMP #$DF     <span class="comment">;   return;</span>
9DD9: BEQ $9DE7    <span class="comment">; }</span>

9DDB: LDA $00F7
9DDD: STA $00CE    <span class="comment">; heldButtons = getHeldButtons();</span>

9DDF: LDA #$00
9DE1: STA $00CF    <span class="comment">; repeats = 0;</span>
  
9DE3: RTS          <span class="comment">; return;</span>

<span class="label">buttonsNotChanged:</span>

9DE4: INC $00CF    <span class="comment">; repeats++;</span>

9DE6: RTS          
9DE7: RTS          <span class="comment">; return;</span></pre></div></div>
    <p>But, the table is stored in PRG-ROM.  Attempting to write to it 
has no effect on the stored data.  Instead, each write triggers a bank 
switch resulting in the trippy effect shown below.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/24.png"></p>
    <p>This suggests that the developers were able to execute the program partially or entirely in RAM.</p>
    <p>To get around this inconvenience, I created <span class="code">lua/RecordDemo.lua</span>, available in the <a href="http://meatfighter.com/nintendotetrisai/NintendoTetrisAI.zip">source zip</a>.
  After switching to demo recording mode, it redirects table writes to 
the Lua console.  From there, the bytes can be copied and pasted into 
the ROM.</p>
    <p>To record your own demo, first launch FCEUX and load the Nintendo
 Tetris ROM (File | Open ROM...).  Then, open a Lua Script window (File |
 Lua | New Lua Script Window...) and either browse for the file or type 
in the path.  When ready, press the Run button to begin demo recording 
mode, followed by a mouse click on the FCEUX window to restore the input
 focus.  You will be able to control the pieces until the buttons table 
reaches capacity.  At that point, the game will automatically return to 
the Title Screen.  Press Stop in the Lua Script window to terminate the 
script.  The recorded data will appear in the Output Console as shown 
below.</p>    
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/25.png"></p>
    <p>Select the full contents and copy it to the clipboard (Ctrl+C).  
Then, launch the Hex Editor (Debug | Hex Editor...).  From the Hex 
Editor menu, select View | ROM File followed by File | Goto Address.  In
 the Goto dialog box, enter 5D10 (the location of the demo buttons table
 in the ROM file) and press Ok.  Next, paste the clipboard contents 
(Ctrl+V).</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/26.png"></p>
    <p>Finally, from the FCEUX menu, select NES | Reset.  If you managed
 to follow all these steps, then the demo should be replaced by your 
recorded version.</p>
    <p>If you wish to preserve your changes, from the Hex Editor menu, 
select File | Save Rom As... and enter in a name for the modified ROM 
file before hitting Save.</p>
    <p>The sequence of spawned Tetriminos can be customized in a similar way.</p>
    
    <h3><a id="The_Kill_Screen">The Kill Screen</a></h3>
    <p>As discussed above, most players cannot endure the drop speed of 
level 29, which swiftly brings the game to an end. For this reason, it 
has become associated with the notation of a kill screen. But, 
technically, a kill screen prevents the player from advancing due to a 
bug whereas the rapid drop is actually a feature.   The designers were 
kind enough to let the game continue as long as the player could 
maintain superhuman speed.</p>
    <p>The actual kill screen occurs around 1550 lines.  It manifests 
itself in different ways.  Sometimes the game resets.  Other times, the 
screen just goes black.  Usually, the game freezes just after clearing a
 line as shown below.  And, these effects are often preceded by random 
visual artifacts.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/27.png"></p>
    <p>The kill screen is the result of a bug in the code that adds 
points to the score when lines are cleared.  The 6-digit score is stored
 as little endian 24-bit packed BCD and it is located across <span class="code">$0053</span>–<span class="code">$0055</span>.
  A table is used to convert between number of lines cleared and gained 
points; each entry is a little endian 16-bit packed BCD value.</p>
    <div class="centered"><div class="source"><pre>9CA5: <span class="num">00 00</span>  <span class="comment">; 0:    0</span>
9CA7: <span class="num">40 00</span>  <span class="comment">; 1:   40</span>
9CA9: <span class="num">00 01</span>  <span class="comment">; 2:  100</span>
9CAB: <span class="num">00 03</span>  <span class="comment">; 3:  300</span>
9CAD: <span class="num">00 12</span>  <span class="comment">; 4: 1200</span></pre></div></div>     
    <p>After the total lines count and potentially the level are 
incremented, a value in that list is multiplied by level number plus one
 and the result is added to the score.  This is nicely conveyed by a 
table in the Nintendo Tetris Instruction Booklet:</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/28.png"></p>
    <p>As listed below, that multiplication is emulated by a loop that 
repeatedly adds the points to the score.  It executes when a piece is 
locked even when no lines are cleared.</p>
    <div class="centered"><div class="source"><pre>9C31: LDA $0044
9C33: STA $00A8
9C35: INC $00A8    <span class="comment">; for(i = 0; i &lt;= level; i++) {</span>

9C37: LDA $0056    
9C39: ASL
9C3A: TAX          
9C3B: LDA $9CA5,X  <span class="comment">;   points[0] = pointsTable[2 * completedLines];</span>

9C3E: CLC
9C3F: ADC $0053
9C41: STA $0053    <span class="comment">;   score[0] += points[0];</span> 

9C43: CMP #$A0     
9C45: BCC $9C4E    <span class="comment">;   if (upper digit of score[0] &gt; 9) {</span>

9C47: CLC
9C48: ADC #$60
9C4A: STA $0053    <span class="comment">;     upper digit of score[0] -= 10;</span>
9C4C: INC $0054    <span class="comment">;     score[1]++;</span>
                   <span class="comment">;   }</span>

9C4E: INX
9C4F: LDA $9CA5,X  <span class="comment">;   points[1] = pointsTable[2 * completedLines + 1];</span>

9C52: CLC
9C53: ADC $0054
9C55: STA $0054    <span class="comment">;   score[1] += points[1];</span>

9C57: AND #$0F     
9C59: CMP #$0A
9C5B: BCC $9C64    <span class="comment">;   if (lower digit of score[1] &gt; 9) {</span>

9C5D: LDA $0054    
9C5F: CLC          <span class="comment">;     lower digit of score[1] -= 10;</span>
9C60: ADC #$06     <span class="comment">;     increment upper digit of score[1];</span>
9C62: STA $0054    <span class="comment">;   }</span>

9C64: LDA $0054    
9C66: AND #$F0
9C68: CMP #$A0
9C6A: BCC $9C75    <span class="comment">;   if (upper digit of score[1] &gt; 9) {</span> 

9C6C: LDA $0054    
9C6E: CLC
9C6F: ADC #$60
9C71: STA $0054    <span class="comment">;     upper digit of score[1] -= 10;</span>
9C73: INC $0055    <span class="comment">;     score[2]++;</span>
                   <span class="comment">;   }</span>

9C75: LDA $0055
9C77: AND #$0F
9C79: CMP #$0A
9C7B: BCC $9C84    <span class="comment">;   if (lower digit of score[2] &gt; 9) {</span>

9C7D: LDA $0055    
9C7F: CLC          <span class="comment">;     lower digit of score[2] -= 10;</span>
9C80: ADC #$06     <span class="comment">;     increment upper digit of score[2];</span>
9C82: STA $0055    <span class="comment">;   }</span>

9C84: LDA $0055    
9C86: AND #$F0
9C88: CMP #$A0
9C8A: BCC $9C94    <span class="comment">;   if (upper digit of score[2] &gt; 9) {</span>

9C8C: LDA #$99
9C8E: STA $0053         
9C90: STA $0054         
9C92: STA $0055    <span class="comment">;     max out score to 999999;</span>
                   <span class="comment">;   }</span>

9C94: DEC $00A8
9C96: BNE $9C37    <span class="comment">; }</span></pre></div></div>
    <p>It is unfortunate that the <a href="http://en.wikipedia.org/wiki/Ricoh_2A03">Ricoh 2A03</a>
 lacks the binary-coded decimal mode of the 6502; it could have 
simplified much of the body of the loop.  Instead, the addition is 
carried out stepwise using binary mode.  Any digit that exceeds 9 after 
the addition is adjusted by effectively subtracting 10 and incrementing 
the digit directly to the left.  For instance, <span class="code">$07 + $07 = $0E</span>, which is converted to <span class="code">$14</span>.  But, that scheme is not entirely foolproof.  For example, <span class="code">$09 + $09 = $12</span> and the checks are incapable of transforming that into <span class="code">$18</span>.
  To compensate, none of the decimal digits in the entries of the points
 table exceed 6.  Also, to save a check, the final digit of all the 
entries is 0.</p>
    <p>This long and complicated loop takes time to execute.  For high 
levels, the large number of iterations affects the timing of the game as
 each frame takes longer than 1/60th of a second to generate.  That 
ultimately leads to the various manifestations of the kill screen.</p>
    <p>The AI Lua Script caps the number of iterations of the loop at 
30, the maximum value that the game designers expected it to reach, 
eliminating the kill screen.</p>
    
    <h3><a id="Endings">Endings</a></h3>
    <p>The Nintendo Tetris Instruction Booklet describes the A-Type game as:</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/49.png"></p>
    <p>And, the game rewards players who gain significantly high scores 
with one of five ending animations.  The choice of ending is based 
entirely on the 2 left-most digits of the 6-digit score.  As shown 
below, the player must achieve at least 30,000 points to receive any of 
the endings.</p>    
    <div class="centered"><div class="source"><pre>9A4D: LDA $0075
9A4F: CMP #$03   
9A51: BCC $9A5E  <span class="comment">; if (score[2] &gt;= $03) {</span>

9A53: LDA #$80
9A55: JSR $A459
9A58: JSR $9E3A
9A5B: JMP $9A64  <span class="comment">;   select ending;</span> 
                 <span class="comment">; }</span></pre></div></div>
    <p>It should be noted that <span class="code">$0060</span>–<span class="code">$007F</span> is a mirror of <span class="code">$0040</span>–<span class="code">$005F</span>.  The score is replicated across <span class="code">$0073</span>–<span class="code">$0075</span>.</p>
    <p>If that first check passes, the ending animation is selected by the following switch.</p>             
    <div class="centered"><div class="source"><pre>             
A96E: LDA #$00
A970: STA $00C4
A972: LDA $0075  <span class="comment">; if (score[2] &lt; $05) {</span>
A974: CMP #$05   <span class="comment">;   ending = 0;</span>
A976: BCC $A9A5  <span class="comment">; }</span>

A978: LDA #$01
A97A: STA $00C4
A97C: LDA $0075  <span class="comment">; else if (score[2] &lt; $07) {</span>
A97E: CMP #$07   <span class="comment">;   ending = 1;</span>
A980: BCC $A9A5  <span class="comment">; }</span>

A982: LDA #$02
A984: STA $00C4
A986: LDA $0075  <span class="comment">; else if (score[2] &lt; $10) {</span>
A988: CMP #$10   <span class="comment">;   ending = 2;</span>
A98A: BCC $A9A5  <span class="comment">; }</span>

A98C: LDA #$03
A98E: STA $00C4
A990: LDA $0075  <span class="comment">; else if (score[2] &lt; $12) {</span>
A992: CMP #$12   <span class="comment">;   ending = 3;</span>
A994: BCC $A9A5  <span class="comment">; }</span>

A996: LDA #$04   <span class="comment">; else {</span>
A998: STA $00C4  <span class="comment">;   ending = 4;</span>
                 <span class="comment">; }</span></pre></div></div>                
    <p>The endings consist of rockets of increasing size launched from a
 pad neighboring Saint Basil's Cathedral.  The fourth ending depicts the
 Buran spacecraft, the Soviet version of the US Space Shuttle.  In the 
best ending, the cathedral itself rockets up into the air as a UFO 
hovers over the launch pad.  An image of each ending and its associated 
high score range appear below.</p>
    <table class="img">
      <tbody><tr><td><span class="code">30000–49999</span><br><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/29.png"></td><td><span class="code">50000–69999</span><br><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/30.png"></td><td><span class="code">70000–99999</span><br><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/31.png"></td></tr>
      <tr><td><span class="code">100000–119999</span><br><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/32.png"></td><td><span class="code">120000+</span><br><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/33.png"></td><td></td></tr>
    </tbody></table>
    <p>The B-Type game provides a different challenge, which the Nintendo Tetris Instruction Booklet describes as:</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/50.png"></p>
    <p>If the player successfully clears 25 lines, the game display an 
ending determined by the starting level.  The endings for levels 0–8 
consists of animals and objects flying or running across the frame, 
enigmatically passing behind Saint Basil's Cathedral.  The UFO from the 
best A-Type ending makes an appearance in ending 3.  Ending 4 features 
extinct flying pterosaurs, while ending 7 shows mythical flying dragons.
  Endings 2 and 6 display flightless birds: running penguins and 
ostriches respectively.  Ending 5 is filled with GOOD blimps, not to be 
confused with Goodyear blimps.  And, multiple Buran spacecraft zoom 
across the screen in ending 8, even though there was only ever one of 
them.</p>
    <p>The starting height (plus 1) acts as a multiplier, rewarding the player with more animals/objects for the greater difficulty.</p>
    <p>The best B-Type ending features a castle ebullient with 
characters from the Nintendo universe: Princess Peach clapping her 
hands, Kid Icarus playing the violin, Donkey Kong playing a bass drum, 
Mario and Luigi dancing, Bowser playing the accordion, Samus playing the
 cello and Link playing the flute as the domes of Saint Basil's 
Cathedral rocket up into the air.  The starting height establishes the 
number of these elements revealed during the ending.</p>
    <p>Images of all 10 endings follow.</p>
    <table class="img">
      <tbody><tr><td><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/34.png"></td><td><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/35.png"></td><td><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/36.png"></td></tr>
      <tr><td><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/37.png"></td><td><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/38.png"></td><td><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/39.png"></td></tr>
      <tr><td><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/40.png"></td><td><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/41.png"></td><td><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/42.png"></td></tr>
      <tr><td><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/43.png"></td><td></td><td></td></tr>
    </tbody></table> 
    <p>The AI can rapidly plow through the 25 lines required by B-Type 
games at any starting level and height, providing a convenient way to 
watch any of the endings.  It is also fascinating to witness how it 
deals with large stacks of random blocks.</p>
    <p>Endings 0–8 display up to 6 objects moving across the frame.  The y-coordinates of the objects are stored in a table located at <span class="code">$A7B7</span>.</p>
    <div class="centered"><div class="source"><pre>A7B7: <span class="num">98 A8 C0 A8 90 B0</span>  <span class="comment">; 0</span>
A7BD: <span class="num">B0 B8 A0 B8 A8 A0</span>  <span class="comment">; 1</span>
A7C3: <span class="num">C8 C8 C8 C8 C8 C8</span>  <span class="comment">; 2</span>
A7C9: <span class="num">30 20 40 28 A0 80</span>  <span class="comment">; 3</span>
A7CF: <span class="num">A8 88 68 A8 48 78</span>  <span class="comment">; 4</span>
A7D5: <span class="num">58 68 18 48 78 38</span>  <span class="comment">; 5</span>
A7DB: <span class="num">C8 C8 C8 C8 C8 C8</span>  <span class="comment">; 6</span>
A7E1: <span class="num">90 58 70 A8 40 38</span>  <span class="comment">; 7</span>
A7E7: <span class="num">68 88 78 18 48 A8</span>  <span class="comment">; 8</span></pre></div></div>    
    <p>The horizontal spacing between the objects is held in a table at <span class="code">$A77B</span>.</p>
    <div class="centered"><div class="source"><pre>A77B: <span class="num">3A 24 0A 4A 3A FF</span>  <span class="comment">; 0</span>
A781: <span class="num">22 44 12 32 4A FF</span>  <span class="comment">; 1</span>
A787: <span class="num">AE 6E 8E 6E 1E 02</span>  <span class="comment">; 2</span>
A78D: <span class="num">42 42 42 42 42 02</span>  <span class="comment">; 3</span>
A793: <span class="num">22 0A 1A 04 0A FF</span>  <span class="comment">; 4</span>
A799: <span class="num">EE DE FC FC F6 02</span>  <span class="comment">; 5</span>
A79F: <span class="num">80 80 80 80 80 FF</span>  <span class="comment">; 6</span>
A7A5: <span class="num">E8 E8 E8 E8 48 FF</span>  <span class="comment">; 7</span>
A7AB: <span class="num">80 AE 9E 90 80 02</span>  <span class="comment">; 8</span></pre></div></div>
    <p>A sequence of signed values at <span class="code">$A771</span> determines the speed and direction of the objects.</p>
    <div class="centered"><div class="source"><pre>A771: <span class="num">01</span>  <span class="comment">; 0:  1</span> 
A772: <span class="num">01</span>  <span class="comment">; 1:  1</span>
A773: <span class="num">FF</span>  <span class="comment">; 2: -1</span>
A774: <span class="num">FC</span>  <span class="comment">; 3: -4</span>
A775: <span class="num">01</span>  <span class="comment">; 4:  1</span>
A776: <span class="num">FF</span>  <span class="comment">; 5: -1</span>
A777: <span class="num">02</span>  <span class="comment">; 6:  2</span>
A778: <span class="num">02</span>  <span class="comment">; 7:  2</span>
A779: <span class="num">FE</span>  <span class="comment">; 8: -1</span></pre></div></div>
    <p>The sprite indices are located at <span class="code">$A7F3</span>.</p>
    <div class="centered"><div class="source"><pre>A7F3: <span class="num">2C</span>  <span class="comment">; 0: dragonfly</span>
A7F4: <span class="num">2E</span>  <span class="comment">; 1: dove</span>
A7F5: <span class="num">54</span>  <span class="comment">; 2: penguin</span>
A7F6: <span class="num">32</span>  <span class="comment">; 3: UFO</span>
A7F7: <span class="num">34</span>  <span class="comment">; 4: pterosaur</span>
A7F8: <span class="num">36</span>  <span class="comment">; 5: blimp</span>
A7F9: <span class="num">4B</span>  <span class="comment">; 6: ostrich</span>
A7FA: <span class="num">38</span>  <span class="comment">; 7: dragon</span>
A7FB: <span class="num">3A</span>  <span class="comment">; 8: Buran</span></pre></div></div>
    <p>Each object actually consists of 2 sprites with adjacent indices.
  Add 1 for the second index.  For example, the dragon consists of <span class="code">$38</span> and <span class="code">$39</span>.  The tiles for those sprites appear in the pattern tables below.</p>
    <table class="img">
      <tbody><tr><td><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/44.png"></td><td><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/45.png"></td><td><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/46.png"></td></tr>
    </tbody></table>   
    <p>The center pattern table is the same one discussed above for 
displaying Tetriminos and the playfield.  Interestingly, it contains the
 full alphabet whereas the others only contain a subset to save space.  
But, what is more interesting is the airplane and the helicopter sprites
 in the pattern table on the left; they do not appear in any of the 
endings or anywhere else in the game.  It turns out that the airplane 
and the helicopter have sprite indices of <span class="code">$30</span> and <span class="code">$16</span> respectively and it is possible to modify the table above to see them in action.  The results appear below.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/47.png"></p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/48.png"></p>
    <p>Unfortunately, the helicopter skids do not appear, but the main and tail rotors are nicely animated.</p>
        
    <h3><a id="2_Player_Versus">2 Player Versus</a></h3>
    <p>Nintendo Tetris contains a hidden, unfinished 2 player versus 
mode that can be enabled by internally setting the number of players (<span class="code">$00BE</span>) to 2.  As shown below, 2 playfields appear side-by-side on top of the single player mode background.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/54.png"></p>
    <p>No border appears between the playfields because the center region of the background is solid black.  The <span class="code">003</span>
 values displayed above the playfields indicate the number of lines 
cleared by each player.  A lone, shared piece preview appears in the 
same location as it did in single player mode, which unfortunately, 
coincides with the right playfield.  The squares and other tiles are not
 colored properly.  And, when a player loses, the game resets.</p>
    <p>Those issues aside, the mode is playable.  Each player can 
independently control the pieces in the corresponding playfield.  And, 
when a player achieves a Double, Triple or Tetris, garbage lines 
containing a single missing square push up from beneath the opponent's 
playfield.</p>
    <p>The additional playfield is located at <span class="code">$0500</span>.  And, <span class="code">$0060</span>–<span class="code">$007F</span>, which is normally a mirror of <span class="code">$0040</span>–<span class="code">$005F</span>, is used for the second player.</p>
    <p>A rushed development schedule may have extinguished this 
attractive feature.  Or, it may have been left incomplete due to 
something more intentional.  One of the reasons that Tetris was selected
 as the pack-in game for the Nintendo Game Boy is that it promoted the <a href="http://en.wikipedia.org/wiki/Game_Link_Cable">Game Link Cable</a>,
 an accessory that hooked 2 Game Boys together for 2 player versus mode.
  That cable introduced a social element to the system, encouraging 
friends to go out and buy a Game Boy to link into the fun.  Perhaps 
Nintendo feared that if the console version of the game provided 2 
player versus mode that the promotional power that Tetris had on the 
Game Boy might actually be weakened.</p>
    
    <h3><a id="Music">Music and Sound Effects</a></h3>
    <p>Background music is triggered when <span class="code">$06F5</span> is set to one of the values listed in the table below.</p>
    <table class="table1">
      <tbody><tr><th>Value</th><th>Description</th></tr>
      <tr><td><span class="code">01</span></td><td style="text-align: left;">Unused title screen music</td></tr>
      <tr><td><span class="code">02</span></td><td style="text-align: left;">B-Type goal achieved</td></tr>
      <tr><td><span class="code">03</span></td><td style="text-align: left;">Music-1</td></tr>
      <tr><td><span class="code">04</span></td><td style="text-align: left;">Music-2</td></tr>
      <tr><td><span class="code">05</span></td><td style="text-align: left;">Music-3</td></tr>
      <tr><td><span class="code">06</span></td><td style="text-align: left;">Music-1 allegro</td></tr>
      <tr><td><span class="code">07</span></td><td style="text-align: left;">Music-2 allegro</td></tr>
      <tr><td><span class="code">08</span></td><td style="text-align: left;">Music-3 allegro</td></tr>
      <tr><td><span class="code">09</span></td><td style="text-align: left;">Congratulations screen</td></tr>
      <tr><td><span class="code">0A</span></td><td style="text-align: left;">Endings</td></tr>
      <tr><td><span class="code">0B</span></td><td style="text-align: left;">B-Type goal achieved</td></tr>
    </tbody></table>    
    <p>You can listen to the unused title screen music <a href="http://meatfighter.com/nintendotetrisai/tetris-01.mp3">here</a>.  The title screen in the actual game is silent.</p>
    <p>Music-1 is a version of the "<a href="http://simple.wikipedia.org/wiki/Dance_of_the_Sugar_Plum_Fairy">Dance of the Sugar Plum Fairy</a>," the music for the ballerina in the third movement in <a href="http://en.wikipedia.org/wiki/Pyotr_Ilyich_Tchaikovsky">Tchaikovsky’s</a> <a href="http://simple.wikipedia.org/wiki/The_Nutcracker_pas_de_deux"><i>The Nutcracker pas de deux</i></a>.  The ending music is a variation of the "<a href="http://en.wikipedia.org/wiki/Toreador_Song">Toreador Song</a>," the aria from the opera <a href="http://en.wikipedia.org/wiki/Carmen"><i>Carmen</i></a> by <a href="http://en.wikipedia.org/wiki/Georges_Bizet">Georges Bizet</a>.  Those pieces were arranged by <a href="http://en.wikipedia.org/wiki/Hirokazu_Tanaka">Hirokazu Tanaka</a>, the composer of all the other music in the game.</p>
    <p>Music-2 was inspired by traditional Russian folk songs.  And, 
Music-3 is mysterious, futuristic and mellow; at one point, it was the 
hold music heard on Nintendo of America’s customer service line.</p>
    <p>To help push the player into a state of panic when the height of 
the pile grows close to the playfield ceiling, a rapid tempo version of 
the background music (<span class="code">$06</span>–<span class="code">$08</span>) commences.</p>
    <p>Notably missing is "<a href="http://en.wikipedia.org/wiki/Korobeiniki">Korobeiniki</a>", the well-known theme heard in Game Boy Tetris.</p>
    <p>Sound effects are initiated by writing to <span class="code">$06F0</span> and <span class="code">$06F1</span> as described in the following table.</p>
    <table class="table1">
      <tbody><tr><th>Address</th><th>Value</th><th>Description</th></tr>
      <tr><td><span class="code">06F0</span></td><td><span class="code">02</span></td><td style="text-align: left;">Game over curtain</td></tr>
      <tr><td><span class="code">06F0</span></td><td><span class="code">03</span></td><td style="text-align: left;">Ending rocket</td></tr>
      <tr><td><span class="code">06F1</span></td><td><span class="code">01</span></td><td style="text-align: left;">Menu option select</td></tr>
      <tr><td><span class="code">06F1</span></td><td><span class="code">02</span></td><td style="text-align: left;">Menu screen select</td></tr>
      <tr><td><span class="code">06F1</span></td><td><span class="code">03</span></td><td style="text-align: left;">Shift Tetrimino</td></tr>
      <tr><td><span class="code">06F1</span></td><td><span class="code">04</span></td><td style="text-align: left;">Tetris achieved</td></tr>
      <tr><td><span class="code">06F1</span></td><td><span class="code">05</span></td><td style="text-align: left;">Rotate Tetrimino</td></tr>
      <tr><td><span class="code">06F1</span></td><td><span class="code">06</span></td><td style="text-align: left;">Level up</td></tr>
      <tr><td><span class="code">06F1</span></td><td><span class="code">07</span></td><td style="text-align: left;">Lock Tetrimino</td></tr>
      <tr><td><span class="code">06F1</span></td><td><span class="code">08</span></td><td style="text-align: left;">Chirp-chirp</td></tr>
      <tr><td><span class="code">06F1</span></td><td><span class="code">09</span></td><td style="text-align: left;">Line clearing</td></tr>
      <tr><td><span class="code">06F1</span></td><td><span class="code">0A</span></td><td style="text-align: left;">Line completed</td></tr>
    </tbody></table>
    
    <h3><a id="Play_States_and_Render_Modes">Play States and Render Modes</a></h3>
    <p>During play, the current state of the game is represented as an integer at <span class="code">$0048</span>.  Most of the time, it is set to <span class="code">$01</span>, indicating that the player is controlling the active Tetrimino.  However, when the piece locks, the game steps through states <span class="code">$02</span> through <span class="code">$08</span>, as listed in the table below.</p>
    <table class="table1">
      <tbody><tr><th>State</th><th>Description</th></tr>
      <tr><td><span class="code">00</span></td><td style="text-align: left;">Unassign orientation ID</td></tr>
      <tr><td><span class="code">01</span></td><td style="text-align: left;">Player controls active Tetrimino</td></tr>
      <tr><td><span class="code">02</span></td><td style="text-align: left;">Lock Tetrimino into playfield</td></tr>
      <tr><td><span class="code">03</span></td><td style="text-align: left;">Check for completed rows</td></tr>
      <tr><td><span class="code">04</span></td><td style="text-align: left;">Display line clearing animation</td></tr>
      <tr><td><span class="code">05</span></td><td style="text-align: left;">Update lines and statistics</td></tr>
      <tr><td><span class="code">06</span></td><td style="text-align: left;">B-Type goal check</td></tr>
      <tr><td><span class="code">07</span></td><td style="text-align: left;">Unused</td></tr>
      <tr><td><span class="code">08</span></td><td style="text-align: left;">Spawn next Tetrimino</td></tr>
      <tr><td><span class="code">09</span></td><td style="text-align: left;">Unused</td></tr>
      <tr><td><span class="code">0A</span></td><td style="text-align: left;">Update game over curtain</td></tr>
      <tr><td><span class="code">0B</span></td><td style="text-align: left;">Increment play state</td></tr>
    </tbody></table>
    <p>The code branches on the play state at <span class="code">$81B2</span>:</p>
    <div class="centered"><div class="source"><pre>81B2: LDA $0048
81B4: JSR $AC82  <span class="comment">; switch(playState) {</span>
81B7: <span class="num">2F 9E</span>      <span class="comment">;   case 00: goto 9E2F;  // Unassign orientationID</span>
81B9: <span class="num">CF 81</span>      <span class="comment">;   case 01: goto 81CF;  // Player controls active Tetrimino</span>
81BB: <span class="num">A2 99</span>      <span class="comment">;   case 02: goto 99A2;  // Lock Tetrimino into playfield</span>
81BD: <span class="num">6B 9A</span>      <span class="comment">;   case 03: goto 9A6B;  // Check for completed rows</span>
81BF: <span class="num">39 9E</span>      <span class="comment">;   case 04: goto 9E39;  // Display line clearing animation</span>
81C1: <span class="num">58 9B</span>      <span class="comment">;   case 05: goto 9B58;  // Update lines and statistics</span>
81C3: <span class="num">F2 A3</span>      <span class="comment">;   case 06: goto A3F2;  // B-Type goal check; Unused frame for A-Type</span>
81C5: <span class="num">03 9B</span>      <span class="comment">;   case 07: goto 9B03;  // Unused frame; Execute unfinished 2 player mode logic</span>
81C7: <span class="num">8E 98</span>      <span class="comment">;   case 08: goto 988E;  // Spawn next Tetrimino</span>
81C9: <span class="num">39 9E</span>      <span class="comment">;   case 09: goto 9E39;  // Unused</span>
81CB: <span class="num">11 9A</span>      <span class="comment">;   case 0A: goto 9A11;  // Update game over curtain</span>
81CD: <span class="num">37 9E</span>      <span class="comment">;   case 0B: goto 9E37;  // Increment play state</span>
                 <span class="comment">; }</span></pre></div></div>     
    <p>For state <span class="code">$00</span>, the switch jumps to the following the code that assigns <span class="code">$13</span> to <span class="code">orientationID</span>, indicating that it is not set.</p>
    <div class="centered"><div class="source"><pre>9E2F: LDA #$13
9E31: STA $0042  <span class="comment">; orientationID = UNASSIGNED;</span>

9E33: RTS        <span class="comment">; return;</span></pre></div></div> 
    <p>  The handler is never invoked; however, play state <span class="code">$00</span> serves as a signal for other parts of the code.</p>
    <p>State <span class="code">$01</span> enables the player to shift, rotate and drop the active Tetrimino:</p>
    <div class="centered"><div class="source"><pre>81CF: JSR $89AE  <span class="comment">; shift Tetrimino;</span>
81D2: JSR $88AB  <span class="comment">; rotate Tetrimino;</span>
81D5: JSR $8914  <span class="comment">; drop Tetrimino;</span>

81D8: RTS        <span class="comment">; return;</span></pre></div></div> 
    <p>As discussed in prior sections, the shift, rotate and drop 
subroutines validate new Tetrimino positions before committing to a 
move.  The only way that a piece can lock at an invalid position is if 
it spawned on top of an existing piece, ending the game.  As listed 
below, the code for state <span class="code">$02</span> performs that check.</p>    
    <div class="centered"><div class="source"><pre>99A2: JSR $948B  <span class="comment">; if (new position valid) {</span>
99A5: BEQ $99B8  <span class="comment">;   goto updatePlayfield;</span>
                 <span class="comment">; }</span>  

99A7: LDA #$02
99A9: STA $06F0  <span class="comment">; play curtain sound effect;</span>

99AC: LDA #$0A
99AE: STA $0048  <span class="comment">; playState = UPDATE_GAME_OVER_CURTAIN;</span>

99B0: LDA #$F0
99B2: STA $0058  <span class="comment">; curtainRow = -16;</span>

99B4: JSR $E003  <span class="comment">; updateAudio();</span>

99B7: RTS        <span class="comment">; return;</span></pre></div></div>
    <p>If the locked position is valid, it marks the 4 associated cells of the playfield as solid.  Otherwise, it changes to state <span class="code">$0A</span>, the dreaded game over curtain.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/73.png"></p>
    <p>The curtain is drawn from the top of the playfield to the bottom, advancing one row every 4 frames.  The <span class="code">curtainRow</span> (<span class="code">$0058</span>)
 is initialized to −16, providing an extra delay of 0.27 seconds between
 the final lock and the beginning of the animation.  At <span class="code">$9A21</span> in the state <span class="code">$0A</span> code below, the multiplication table, which erroneously gets displayed as level numbers, is accessed to scale <span class="code">curtainRow</span> by 10.  Also, as revealed earlier, the code at <span class="code">$9A51</span> triggers an ending animation if the player's score is at least 30,000 points; otherwise, it waits for Start.</p>
    <div class="centered"><div class="source"><pre>9A11: LDA $0058    <span class="comment">; if (curtainRow == 20) {</span>
9A13: CMP #$14     <span class="comment">;   goto endGame;</span>
9A15: BEQ $9A47    <span class="comment">; }</span>

9A17: LDA $00B1    <span class="comment">; if (frameCounter not divisible by 4) {</span>
9A19: AND #$03     <span class="comment">;   return;</span> 
9A1B: BNE $9A46    <span class="comment">; }</span>

9A1D: LDX $0058    <span class="comment">; if (curtainRow &lt; 0) {</span>
9A1F: BMI $9A3E    <span class="comment">;   goto incrementCurtainRow;</span>
                   <span class="comment">; }</span>  

9A21: LDA $96D6,X  
9A24: TAY          <span class="comment">; rowIndex = 10 * curtainRow;</span>  

9A25: LDA #$00
9A27: STA $00AA    <span class="comment">; i = 0;</span>

9A29: LDA #$13
9A2B: STA $0042    <span class="comment">; orientationID = NONE;</span>

<span class="label">drawCurtainRow:</span>

9A2D: LDA #$4F     
9A2F: STA ($B8),Y  <span class="comment">; playfield[rowIndex + i] = CURTAIN_TILE;</span>
9A31: INY          
9A32: INC $00AA    <span class="comment">; i++;</span>
9A34: LDA $00AA
9A36: CMP #$0A     <span class="comment">; if (i != 10) {</span>
9A38: BNE $9A2D    <span class="comment">;   goto drawCurtainRow;</span>
                   <span class="comment">; }</span>

9A3A: LDA $0058
9A3C: STA $0049    <span class="comment">; vramRow = curtainRow;</span>

<span class="label">incrementCurtainRow:</span>

9A3E: INC $0058    <span class="comment">; curtainRow++;</span>

9A40: LDA $0058    <span class="comment">; if (curtainRow != 20) {</span>
9A42: CMP #$14     <span class="comment">;   return;</span>
9A44: BNE $9A46    <span class="comment">; }</span>

9A46: RTS          <span class="comment">; return;</span>

<span class="label">endGame:</span>

9A47: LDA $00BE    
9A49: CMP #$02
9A4B: BEQ $9A64    <span class="comment">; if (numberOfPlayers == 1) {</span>

9A4D: LDA $0075
9A4F: CMP #$03
9A51: BCC $9A5E    <span class="comment">;   if (score[2] &gt;= $03) {</span>

9A53: LDA #$80
9A55: JSR $A459
9A58: JSR $9E3A
9A5B: JMP $9A64    <span class="comment">;     select ending;</span> 
                   <span class="comment">;   }</span>

9A5E: LDA $00F5    <span class="comment">;   if (not just pressed Start) {</span>
9A60: CMP #$10     <span class="comment">;     return;</span>
9A62: BNE $9A6A    <span class="comment">;   }</span>
                   <span class="comment">; }</span>

9A64: LDA #$00
9A66: STA $0048    <span class="comment">; playState = INITIALIZE_ORIENTATION_ID;</span>
9A68: STA $00F5    <span class="comment">; clear newly pressed buttons;</span>

9A6A: RTS          <span class="comment">; return;</span></pre></div></div>
    <p>The code ends by setting the play state to <span class="code">$00</span>, but the corresponding handler does not get called since it is game over.</p>
    <p>The playfield rows are incrementally copied to VRAM to display them.  The index of the current row being copied is held in <span class="code">vramRow</span> (<span class="code">$0049</span>).  At <span class="code">$9A3C</span>, <span class="code">vramRow</span> is set to <span class="code">curtainRow</span>, which will ultimately render that row of the curtain visible.</p>
    <p>VRAM manipulation occurs during the vertical blanking interval, 
which is detected by the interrupt handler that was discussed in the <a href="#Legal_Screen">Legal Screen</a> section.  It invokes the subroutine listed below (denoted as <span class="code">render()</span> in the interrupt handler comments).</p>
    <div class="centered"><div class="source"><pre>804B: LDA $00BD
804D: JSR $AC82  <span class="comment">; switch(renderMode) {</span>
8050: <span class="num">B1 82</span>      <span class="comment">;   case 0: goto 82B1;  // Legal and title screens</span>
8052: <span class="num">DA 85</span>      <span class="comment">;   case 1: goto 85DA;  // Menu screens</span>
8054: <span class="num">44 A3</span>      <span class="comment">;   case 2: goto A344;  // Congratulations screen</span>
8056: <span class="num">EE 94</span>      <span class="comment">;   case 3: goto 94EE;  // Play and demo</span>
8058: <span class="num">95 9F</span>      <span class="comment">;   case 4: goto 9F95;  // Ending animation</span>
                 <span class="comment">; }</span></pre></div></div>
    <p>Render mode is similar to game mode.  It is stored at <span class="code">$00BD</span> and it can have one of the following values:</p>
    <table class="table1">
      <tbody><tr><th>Value</th><th>Description</th></tr>
      <tr><td><span class="code">00</span></td><td style="text-align: left;">Legal and title screens</td></tr>
      <tr><td><span class="code">01</span></td><td style="text-align: left;">Menu screens</td></tr>
      <tr><td><span class="code">02</span></td><td style="text-align: left;">Congratulations screen</td></tr>
      <tr><td><span class="code">03</span></td><td style="text-align: left;">Play and demo</td></tr>
      <tr><td><span class="code">04</span></td><td style="text-align: left;">Ending animation</td></tr>      
    </tbody></table>
    <p>Part of render mode <span class="code">$03</span> is listed below.</p>
    <div class="centered"><div class="source"><pre>952A: JSR $9725  <span class="comment">; copyPlayfieldRowToVRAM();</span>
952D: JSR $9725  <span class="comment">; copyPlayfieldRowToVRAM();</span>
9530: JSR $9725  <span class="comment">; copyPlayfieldRowToVRAM();</span>
9533: JSR $9725  <span class="comment">; copyPlayfieldRowToVRAM();</span></pre></div></div>
    <p>As shown below, <span class="code">copyPlayfieldRowToVRAM()</span> transfers the playfield row indexed by <span class="code">vramRow</span> to VRAM.  If <span class="code">vramRow</span> is greater than 20, the subroutine does nothing.</p>
    <div class="centered"><div class="source"><pre>9725: LDX $0049    <span class="comment">; if (vramRow &gt; 20) {</span> 
9727: CPX #$15     <span class="comment">;   return;</span>
9729: BPL $977E    <span class="comment">; }</span>

972B: LDA $96D6,X  
972E: TAY          <span class="comment">; playfieldAddress = 10 * vramRow;</span>

972F: TXA          
9730: ASL           
9731: TAX
9732: INX          <span class="comment">; high = vramPlayfieldRows[vramRow * 2 + 1];</span>
9733: LDA $96EA,X
9736: STA $2006    
9739: DEX          

973A: LDA $00BE    
973C: CMP #$01
973E: BEQ $975E    <span class="comment">; if (numberOfPlayers == 2) {</span>

9740: LDA $00B9    
9742: CMP #$05
9744: BEQ $9752    <span class="comment">;   if (leftPlayfield) {</span>

9746: LDA $96EA,X      
9749: SEC
974A: SBC #$02
974C: STA $2006    <span class="comment">;     low = vramPlayfieldRows[vramRow * 2] - 2;</span>

974F: JMP $9767    <span class="comment">;   } else {</span>

9752: LDA $96EA,X
9755: CLC
9756: ADC #$0C
9758: STA $2006    <span class="comment">;     low = vramPlayfieldRows[vramRow * 2] + 12;</span>

975B: JMP $9767    <span class="comment">; } else {</span>

975E: LDA $96EA,X  
9761: CLC
9762: ADC #$06     <span class="comment">;     low = vramPlayfieldRows[vramRow * 2] + 6;</span>
9764: STA $2006    <span class="comment">; }</span>

                   <span class="comment">; vramAddress = (high &lt;&lt; 8) | low;</span>

9767: LDX #$0A
9769: LDA ($B8),Y  
976B: STA $2007    
976E: INY          <span class="comment">; for(i = 0; i &lt; 10; i++) {</span>
976F: DEX          <span class="comment">;   vram[vramAddress + i] = playfield[playfieldAddress + i];</span>
9770: BNE $9769    <span class="comment">; }</span>

9772: INC $0049    <span class="comment">; vramRow++;</span>
9774: LDA $0049    <span class="comment">; if (vramRow &lt; 20) {</span>
9776: CMP #$14     <span class="comment">;   return;</span>
9778: BMI $977E    <span class="comment">; }</span>

977A: LDA #$20
977C: STA $0049    <span class="comment">; vramRow = 32;</span>

977E: RTS          <span class="comment">; return;</span></pre></div></div>
    <p>The <span class="code">vramPlayfieldRows</span> table (<span class="code">$96EA</span>)
 contains the little endian VRAM addresses corresponding to the 
displayed playfield rows offset by 6 in normal mode and by −2 and 12 for
 the playfields in the unfinished 2 Player Versus mode.  The bytes of 
that table are part of the list of values erroneously displayed as level
 numbers beyond level 29.  The neighboring low and high bytes of each 
address are retrieved individually and they are effectively combined 
into a 16-bit address, which is used in the copy loop.</p>
    <p>At the end of the subroutine, <span class="code">vramRow</span> 
is incremented.  If it reaches 20, it is set to 32, indicating that the 
full copy is completed.  As shown above, only 4 rows are copied per 
frame.</p>
    <p>The state <span class="code">$03</span> handler is responsible 
for identifying completed rows and removing them from the playfield.  
Across 4 separate calls, it scans row offsets <span class="nowrap">[−2, 1]</span>
 about the Tetrimino center (both coordinates of all Tetrimino squares 
existing within that range).  The completed row indices are stored at <span class="code">$004A</span>–<span class="code">$004D</span>; a recorded index of 0 is used to indicate that no completed row was found on that pass.  The handler appears below.</p>
    <div class="centered"><div class="source"><pre>9A6B: LDA $0049    
9A6D: CMP #$20     <span class="comment">; if (vramRow &lt; 32) {</span>
9A6F: BPL $9A74    <span class="comment">;   return;</span>
9A71: JMP $9B02    <span class="comment">; }</span> 

9A74: LDA $0041    <span class="comment">; rowY = tetriminoY - 2;</span> 
9A76: SEC          
9A77: SBC #$02     <span class="comment">; if (rowY &lt; 0) {</span>
9A79: BPL $9A7D    <span class="comment">;   rowY = 0;</span>
9A7B: LDA #$00     <span class="comment">; }</span>

9A7D: CLC
9A7E: ADC $0057    
9A80: STA $00A9    <span class="comment">; rowY += lineIndex;</span> 
 
9A82: ASL          
9A83: STA $00A8    
9A85: ASL
9A86: ASL          
9A87: CLC
9A88: ADC $00A8    
9A8A: STA $00A8    <span class="comment">; rowIndex = 10 * rowY;</span>

9A8C: TAY          
9A8D: LDX #$0A                        
9A8F: LDA ($B8),Y  
9A91: CMP #$EF     <span class="comment">; for(i = 0; i &lt; 10; i++) {</span>
9A93: BEQ $9ACC    <span class="comment">;   if (playfield[rowIndex + i] == EMPTY_TILE) {</span>
9A95: INY          <span class="comment">;     goto rowNotComplete;</span>   
9A96: DEX          <span class="comment">;   }</span>   
9A97: BNE $9A8F    <span class="comment">; }</span>

9A99: LDA #$0A
9A9B: STA $06F1    <span class="comment">; play row completed sound effect;</span>

9A9E: INC $0056    <span class="comment">; completedLines++;</span>

9AA0: LDX $0057    
9AA2: LDA $00A9    
9AA4: STA $4A,X    <span class="comment">; lines[lineIndex] = rowY;</span>

9AA6: LDY $00A8
9AA8: DEY                               
9AA9: LDA ($B8),Y     
9AAB: LDX #$0A        
9AAD: STX $00B8
9AAF: STA ($B8),Y    
9AB1: LDA #$00
9AB3: STA $00B8
9AB5: DEY          <span class="comment">; for(i = rowIndex - 1; i &gt;= 0; i--) {</span>
9AB6: CPY #$FF     <span class="comment">;   playfield[i + 10] = playfield[i];</span>  
9AB8: BNE $9AA9    <span class="comment">; }</span>

9ABA: LDA #$EF     
9ABC: LDY #$00
9ABE: STA ($B8),Y  
9AC0: INY          <span class="comment">; for(i = 0; i &lt; 10; i++) {</span>
9AC1: CPY #$0A     <span class="comment">;   playfield[i] = EMPTY_TILE;</span>
9AC3: BNE $9ABE    <span class="comment">; }</span>

9AC5: LDA #$13
9AC7: STA $0042    <span class="comment">; orientationID = UNASSIGNED;</span>

9AC9: JMP $9AD2    <span class="comment">; goto incrementLineIndex;</span>

<span class="label">rowNotComplete:</span>

9ACC: LDX $0057
9ACE: LDA #$00
9AD0: STA $4A,X    <span class="comment">; lines[lineIndex] = 0;</span>

<span class="label">incrementLineIndex:</span>

9AD2: INC $0057    <span class="comment">; lineIndex++;</span>

9AD4: LDA $0057    <span class="comment">; if (lineIndex &lt; 4) {</span>
9AD6: CMP #$04     <span class="comment">;   return;</span>
9AD8: BMI $9B02    <span class="comment">; }</span>

9ADA: LDY $0056
9ADC: LDA $9B53,Y  
9ADF: CLC
9AE0: ADC $00BC
9AE2: STA $00BC    <span class="comment">; totalGarbage += garbageLines[completedLines];</span>

9AE4: LDA #$00
9AE6: STA $0049    <span class="comment">; vramRow = 0;</span>
9AE8: STA $0052    <span class="comment">; clearColumnIndex = 0;</span>

9AEA: LDA $0056   
9AEC: CMP #$04    
9AEE: BNE $9AF5    <span class="comment">; if (completedLines == 4) {</span>
9AF0: LDA #$04     <span class="comment">;   play Tetris sound effect;</span> 
9AF2: STA $06F1    <span class="comment">; }</span>

9AF5: INC $0048    <span class="comment">; if (completedLines &gt; 0) {</span>
9AF7: LDA $0056    <span class="comment">;   playState = DISPLAY_LINE_CLEARING_ANIMATION;</span>
9AF9: BNE $9B02    <span class="comment">;   return;</span>                    
                   <span class="comment">; }</span>

9AFB: INC $0048    <span class="comment">; playState = UPDATE_LINES_AND_STATISTICS;</span>

9AFD: LDA #$07     
9AFF: STA $06F1    <span class="comment">; play piece locked sound effect;</span>

9B02: RTS          <span class="comment">; return;</span></pre></div></div>
    <p>The <span class="code">vramRow</span> check at the top prevents the handler from executing while playfield rows are being transferred to VRAM (the state <span class="code">$03</span> handler is invoked every frame).  If completed lines are discovered, <span class="code">vramRow</span> is reset to 0 to cause a full transfer.</p>
    <p>The <span class="code">lineIndex</span> (<span class="code">$00A9</span>) is initialized to 0 and it is incremented on each pass.</p>  
    <p>Unlike play state <span class="code">$0A</span> and the playfield copy subroutine that took advantage of the multiplication table at <span class="code">$96D6</span>, the block starting at <span class="code">$9A82</span> multiplies <span class="code">rowY</span> by 10 using shifts and addition:
    </p><div class="centered"><div class="source"><pre>rowIndex = (rowY &lt;&lt; 1) + (rowY &lt;&lt; 3);  <span class="comment">// rowIndex = 2 * rowY + 8 * rowY;</span></pre></div></div>
    <p>This was done because while <span class="code">rowY</span> is constrained to <span class="nowrap">[0, 20]</span>, the multiplication table only covers <span class="nowrap">[0, 19]</span>.  The line scan can actually run off the end of the playfield.  However, as discussed earlier, the game initializes <span class="code">$0400</span>–<span class="code">$04FF</span> to <span class="code">$EF</span> (the empty tile), providing more than 5 additional empty hidden rows below the playfield floor.</p>
    <p>The block starting at <span class="code">$9ADA</span> is part of 
the unfinished 2 Player Versus mode.  As mentioned, clearing lines sends
 garbage over to the opponent's playfield.  The number of garbage lines 
is determined by a table at <span class="code">$9B53</span>:</p>
    <div class="centered"><div class="source"><pre>9B53: <span class="num">00</span>  <span class="comment">; no cleared lines</span>
9B54: <span class="num">00</span>  <span class="comment">; Single</span>
9B55: <span class="num">01</span>  <span class="comment">; Double</span>
9B56: <span class="num">02</span>  <span class="comment">; Triple</span>
9B57: <span class="num">04</span>  <span class="comment">; Tetris</span></pre></div></div>
    <p>The loop at <span class="code">$9AA6</span> shifts the material 
above the completed line down a row.  It takes advantage the fact that 
each row is 10 bytes apart in a contiguous sequence.  The loop following
 it clears the top row.</p>
    <p>The line clearing animation occurs during play state <span class="code">$04</span>, but as shown below, it does not happen within the play state handler, which is entirely empty.</p>
    <div class="centered"><div class="source"><pre>9E39: RTS  <span class="comment">; return;</span></pre></div></div>
    <p>Instead, the following branch of render mode <span class="code">$03</span> is followed during play state <span class="code">$04</span>.</p>
    <div class="centered"><div class="source"><pre>94EE: LDA $0068  
94F0: CMP #$04
94F2: BNE $9522  <span class="comment">; if (playState == DISPLAY_LINE_CLEARING_ANIMATION) {</span>

94F4: LDA #$04
94F6: STA $00B9  <span class="comment">;   leftPlayfield = true;</span>

94F8: LDA $0072
94FA: STA $0052
94FC: LDA $006A
94FE: STA $004A
9500: LDA $006B
9502: STA $004B
9504: LDA $006C
9506: STA $004C
9508: LDA $006D
950A: STA $004D
950C: LDA $0068
950E: STA $0048  <span class="comment">;   mirror values;</span>

9510: JSR $977F  <span class="comment">;   updateLineClearingAnimation();</span>
        
                 <span class="comment">;   ...</span>
                 <span class="comment">; }</span></pre></div></div>    
    <p>The <span class="code">leftPlayfield</span> and mirrored values are for the unfinished 2 Player Versus mode.</p>
    <p>The <span class="code">updateLineClearingAnimation()</span> 
subroutine is listed below.  It is invoked every frame, but the 
condition at the top only enables it to run every fourth frame.  On each
 pass, it loops over the list of completed row indices and it clears 2 
columns from those rows, advancing from the center columns outward.</p>    
    <div class="centered"><div class="source"><pre>977F: LDA $00B1    <span class="comment">; if (frameCounter not divisible by 4) {</span>
9781: AND #$03     <span class="comment">;   return;</span>
9783: BNE $97FD    <span class="comment">; }</span>

9785: LDA #$00     <span class="comment">; for(i = 0; i &lt; 4; i++) {</span>
9787: STA $00AA    <span class="comment">;   rowY = lines[i];</span>
9789: LDX $00AA    <span class="comment">;   if (rowY == 0) {</span>
978B: LDA $4A,X    <span class="comment">;     continue;</span>
978D: BEQ $97EB    <span class="comment">;   }</span>
                   
978F: ASL
9790: TAY         
9791: LDA $96EA,Y  
9794: STA $00A8    <span class="comment">;   low = vramPlayfieldRows[2 * rowY];</span>

9796: LDA $00BE    <span class="comment">;   if (numberOfPlayers == 2) {</span>
9798: CMP #$01     <span class="comment">;     goto twoPlayers;</span>
979A: BNE $97A6    <span class="comment">;   }</span>

979C: LDA $00A8
979E: CLC
979F: ADC #$06
97A1: STA $00A8    <span class="comment">;   low += 6;</span>

97A3: JMP $97BD    <span class="comment">;   goto updateVRAM;</span>

<span class="label">twoPlayers:</span>

97A6: LDA $00B9    
97A8: CMP #$04
97AA: BNE $97B6    <span class="comment">;   if (leftPlayfield) {</span>

97AC: LDA $00A8
97AE: SEC
97AF: SBC #$02
97B1: STA $00A8    <span class="comment">;     low -= 2;</span>

97B3: JMP $97BD    <span class="comment">;   } else {</span>

97B6: LDA $00A8
97B8: CLC
97B9: ADC #$0C     <span class="comment">;     low += 12;</span> 
97BB: STA $00A8    <span class="comment">;   }</span>

<span class="label">updateVRAM:</span>

97BD: INY          
97BE: LDA $96EA,Y
97C1: STA $00A9       
97C3: STA $2006    
97C6: LDX $0052    <span class="comment">;   high = vramPlayfieldRows[2 * rowY + 1];</span>    
97C8: LDA $97FE,X     
97CB: CLC          <span class="comment">;   rowAddress = (high &lt;&lt; 8) | low;</span>
97CC: ADC $00A8       
97CE: STA $2006    <span class="comment">;   vramAddress = rowAddress + leftColumns[clearColumnIndex];</span>
97D1: LDA #$FF
97D3: STA $2007    <span class="comment">;   vram[vramAddress] = 255;</span>

97D6: LDA $00A9 
97D8: STA $2006   
97DB: LDX $0052    <span class="comment">;   high = vramPlayfieldRows[2 * rowY + 1];</span>
97DD: LDA $9803,X  
97E0: CLC          <span class="comment">;   rowAddress = (high &lt;&lt; 8) | low;</span>
97E1: ADC $00A8
97E3: STA $2006    <span class="comment">;   vramAddress = rowAddress + rightColumns[clearColumnIndex];</span>
97E6: LDA #$FF 
97E8: STA $2007    <span class="comment">;   vram[vramAddress] = 255;</span>
                   
97EB: INC $00AA
97ED: LDA $00AA
97EF: CMP #$04
97F1: BNE $9789    <span class="comment">; }</span>

97F3: INC $0052    <span class="comment">; clearColumnIndex++;</span>
97F5: LDA $0052    <span class="comment">; if (clearColumnIndex &lt; 5) {</span>
97F7: CMP #$05     <span class="comment">;   return;</span>
97F9: BMI $97FD    <span class="comment">; }</span>

97FB: INC $0048    <span class="comment">; playState = UPDATE_LINES_AND_STATISTICS;</span>

97FD: RTS          <span class="comment">; return;</span></pre></div></div>
    <p>The 16-bit VRAM address is built up in the same way show in the 
copy playfield subroutine.  However, in this case, it is offset by a 
column index obtained from the table below.</p>
    <div class="centered"><div class="source"><pre>97FE: <span class="num">04 03 02 01 00</span>  <span class="comment">; left columns</span> 
9803: <span class="num">05 06 07 08 09</span>  <span class="comment">; right columns</span></pre></div></div>
    <p>The clearing animation requires 5 passes.  Then, the code advances to the next play state.</p>    
    <p>The play state <span class="code">$05</span> handler contains the code discussed in the <a href="#Lines_and_Statistics">Lines and Statistics</a> section.  The handler ends with this code:</p>
    <div class="centered"><div class="source"><pre>9C9E: LDA #$00
9CA0: STA $0056  <span class="comment">; completedLines = 0;</span>

9CA2: INC $0048  <span class="comment">; playState = B_TYPE_GOAL_CHECK;</span>

9CA4: RTS        <span class="comment">; return;</span></pre></div></div>    
    <p><span class="code">completedLines</span> is not reset until the end of play state <span class="code">$05</span>,
 after it is used to update the total lines count and the score.  This 
sequence permits an interesting bug.  In demo mode, wait for the game to
 get a complete line and then quickly press Start before the line 
clearing animation finishes.  The game will return to the title screen, 
but, if you timed it right, <span class="code">completedLines</span> will retain its value.  Next, begin an A-Type game.  When the first piece locks, the play state <span class="code">$03</span> handler will scan for completed rows.  It won't record any, but it will leave <span class="code">completedLines</span> unchanged.  Finally, when play state <span class="code">$05</span> executes, the total lines count and the score will go up as if those lines were your own.</p>
    <p>The easiest way to do this and the way that will result in the 
most points is to wait for the demo to get a Tetris (2 of them will 
occur).  As soon as you see the screen flash, press Start.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/74.png"></p>
    <p>After launching a new game, the screen actually will continue to 
flash thanks to the following code that is called by the interrupt 
handler.</p>
    <div class="centered"><div class="source"><pre>9673: LDA #$3F
9675: STA $2006
9678: LDA #$0E
967A: STA $2006  <span class="comment">; prepare to modify background tile color;</span>

967D: LDX #$00   <span class="comment">; color = DARK_GRAY;</span>

967F: LDA $0056
9681: CMP #$04
9683: BNE $9698  <span class="comment">; if (completedLines == 4) {</span>

9685: LDA $00B1  
9687: AND #$03
9689: BNE $9698  <span class="comment">;   if (frameCounter divisible by 4) {</span>

968B: LDX #$30   <span class="comment">;     color = WHITE;</span>

968D: LDA $00B1
968F: AND #$07
9691: BNE $9698  <span class="comment">;     if (frameCounter divisible by 8) { </span> 

9693: LDA #$09
9695: STA $06F1  <span class="comment">;       play clear sound effect;</span>

                 <span class="comment">;     }</span>
                 <span class="comment">;   }</span>
                 <span class="comment">; }</span>

9698: STX $2007  <span class="comment">; update background tile color;</span></pre></div></div>
    <p>In fact, if you let the first piece automatically drop all the 
way to the floor of the playfield, the score will increase even more 
because <span class="code">holdDownPoints</span> (<span class="code">$004F</span>) will retain its demo value as well.  This is true even if the demo did not complete any lines.  <span class="code">holdDownPoints</span> is not reset until Down is pressed.</p>    
    <p>Furthermore, if you press Start during the line clearing 
animation of a Tetris in demo mode and then you wait for the demo to 
start again, not only will the demo get credited for the Tetris, its 
timing will get screwed up.  As a result, the demo will actually lose 
the game.  From the game over curtain, you can navigate back to the 
title screen by pressing Start.</p>
    <p>Play state <span class="code">$06</span> performs the goal check for B-Type games.  For A-Type, it is effectively an unused frame.</p>
    <p>Play state <span class="code">$07</span> exclusively contains logic for the unfinished 2 Player Versus mode.  For single player mode, it acts as an unused frame.</p>
    <p>Play state <span class="code">$08</span> was discussed in the <a href="#Spawning_Tetriminos">Spawning Tetriminos</a> and the <a href="#Picking_Tetriminos">Picking Tetriminos</a> sections.</p>
    <p>Play state <span class="code">$09</span> is unused.  And, <span class="code">$0B</span> advances the play state, but it also appears to be unused.</p>
    <p>Finally, here is the main game loop:</p>
    <div class="centered"><div class="source"><pre>                 <span class="comment">; while(true) {</span>

8138: JSR $8161  <span class="comment">;   branchOnGameMode();</span>

813B: CMP $00A7  <span class="comment">;   if (vertical blanking interval wait requested) {</span>
813D: BNE $8142  <span class="comment">;     waitForVerticalBlankingInterval();</span>  
813F: JSR $AA2F  <span class="comment">;   }</span>

8142: LDA $00C0     
8144: CMP #$05        
8146: BNE $815A  <span class="comment">;   if (gameMode == DEMO) {</span>

8148: LDA $00D2  
814A: CMP #$DF
814C: BNE $815A  <span class="comment">;     if (reached end of demo table) {</span>

814E: LDA #$DD
8150: STA $00D2  <span class="comment">;       reset demo table index;</span>

8152: LDA #$00
8154: STA $00B2  <span class="comment">;       clear upper byte of frame counter;</span>

8156: LDA #$01
8158: STA $00C0  <span class="comment">;       gameMode = TITLE_SCREEN;</span>
                 <span class="comment">;     }</span>
                 <span class="comment">;   }</span>
815A: JMP $8138  <span class="comment">; }</span></pre></div></div>    
    <p></p>
    
    <h2><a id="The_Algorithm">The Algorithm</a></h2>
    
    <h3><a id="Overview">Overview</a></h3>
    <p>The algorithm repeatedly performs the following steps:</p>
    <ol>
      <li>Sleep until a new Tetrimino is spawned.</li>
      <li>Observe the type of the newly spawned Tetrimino, the type of 
next Tetrimino (the preview piece) and the contents of the playfield.</li>
      <li>Consider all possible ways to add the 2 Tetriminos to the playfield and rate each possibility.</li>
      <li>Move the newly spawned Tetrimino to coincide with the placement in the best possibility found.</li>
    </ol>
    <p>Each of these steps is discussed in detail below.</p>
    
    <h3><a id="Searching_for_Lock">Searching for Lock</a></h3>
    <p>Consider a simplified version of Tetris where the pieces do not 
drop automatically.  Rather, the only means of advancing downward is 
manually soft dropping.  With timing stripped out of the game, the state
 of an active Tetrimino can be fully described by its position and 
orientation.  It has a known initial spawn state and the operations that
 transform one state into another are:</p>
    <ul>
      <li>Move one step down</li>
      <li>Move one step left</li>
      <li>Move one step right</li>
      <li>Rotate one step counterclockwise</li> 
      <li>Rotate one step clockwise</li>
    </ul>
    <p>Those operations are only applicable when the squares of the 
resultant Tetrimino correspond to empty cells within the boundaries of 
the playfield.  When it is impossible to move one step down, the state 
is considered locked.  However, since lock delay is effectively infinite
 in this simplified Tetris, a locked state can be further transformed by
 the other operations, permitting slides and spins.</p>
    <p>The set of locked states along with the minimal sequence of operations that produce them can be found using <a href="http://en.wikipedia.org/wiki/Breadth-first_search">breadth-first search (BFS)</a>.  As described below, it uses a queue to store intermediate states.</p>
    <ol>    
     <li>Enqueue the spawn state.</li>
     <li>Dequeue a state.</li>
     <li>Obtain successor states by applying the transformation operations.</li>
     <li>If down is not among them, then the dequeued state is a locked state.</li>
     <li>Enqueue the successor states that were not previously visited.</li>
     <li>If the queue is not empty, repeat from step 2.</li>
    </ol>
    <p>The program represents each state as an object with the following fields:</p>
    <div class="centered"><div class="source"><pre>{ x, y, rotation, visited, predecessor }</pre></div></div>
    <p>In preparation, the program creates a 3-dimensional array of state objects (20 rows × 10 columns × 4 rotations), initializing <span class="code">x</span>, <span class="code">y</span> and <span class="code">rotation</span> accordingly.</p>  
    <p>The <span class="code">visited</span> field is marked when a 
state is enqueued.  This is permissible in BFS because each successor 
increases the total path length by 1.  Meaning, it is not possible to 
produce a successor that would need to be inserted anywhere except the 
end of the queue to keep it ordered by increasing path length.</p>
    <p>The <span class="code">predecessor</span> field points to the 
state object from which it descends.  It is set when a state is 
enqueued.    The spawn state has no predecessor.</p>    
    <p>The Tetrimino type and the solid blocks present in the playfield 
ultimately determine the set of lock states discovered during the 
search.  The sequence of moves that generated them can be uncovered (in 
reverse) by repeatedly following the <span class="code">predecessor</span> links back to the spawn state.  When the <span class="code">PLAY_FAST</span> constant at the top of the program is set to <span class="code">true</span>, it skips the predecessors entirely, directly placing the Tetrimino into lock.</p>
    <p>The 3-dimensional array of state objects, the queue and the BFS 
were packaged up into a reusable class.  It provides a search method 
that accepts the playfield (a 2-dimensional array), the Tetrimino type, 
and a listener.  Every time a locked state is found, the playfield is 
updated by adding the Tetrimino at the corresponding location.  Then, 
the modified playfield along with details of the change is passed to the
 listener for processing.  After the listener returns, the playfield is 
restored.</p>
    <p>The listener is used to chain multiple searchers together, 
providing the means of finding all possible ways of adding 2 (or more) 
Tetriminos to the playfield.  The first searcher in the chain executes 
the BFS only once.  However, the second searcher executes the BFS every 
time the first search discovers a locked state.  And so on, if there 
were more searchers in the chain.</p>
    <p>The listener of the final searcher rates the modified playfield. 
 When it encounters a playfield better than the ones examined prior, it 
records the locked state object in use at that time by the first 
searcher in the chain.  Since the first searcher executes the BFS only 
once, the <span class="code">predecessor</span> fields of its state 
objects remain valid after the entire search process is complete.  
Meaning, the final listener effectively captures the pathway that the 
first Tetrimino must take to ultimately lead to the best playfield 
configuration.</p>
    
    <h3><a id="Evaluation_Function">Evaluation Function</a></h3>
    <p>The modified playfield is rated by an evaluation function, a 
weighted sum of various influential factors.  The evaluation function 
used in this application is based on the function developed by <a href="http://ielashi.com/el-tetris-an-improvement-on-pierre-dellacheries-algorithm/">Islam El-Ashi</a>.  It uses the following features:</p>
    <ul>
     <li style="padding-bottom: 14px;"><b>Total Lines Cleared</b><br>This is the total number of lines cleared as a consequence of introducing the 2 Tetriminos.</li>
     <li style="padding-bottom: 14px;"><b>Total Lock Height</b><br>Lock 
height is the height above the playfield floor where a piece locked.  It
 is the vertical distance that a locked piece would drop if all the 
other solid squares in the playfield were removed and the orientation of
 the piece was maintained.  Total lock height is the sum of the lock 
heights of the 2 Tetriminos.</li>  
     <li style="padding-bottom: 14px;"><b>Total Well Cells</b><br>A well
 cell is an empty cell located above all the solid cells within its 
column such that its left and right neighbors are both solid cells; the 
playfield walls are treated as solid cells in this determination.  The 
idea is that a well is a structure open at the top, sealed at the bottom
 and surrounded by walls on both sides.  The possibility of intermittent
 gaps in the well walls means that well cells do not necessarily appear 
in a contiguous stack within a column.</li>
     <li style="padding-bottom: 14px;"><b>Total Column Holes</b><br>A 
column hole is an empty cell directly beneath a solid cell.  The 
playfield floor is not compared to the cell directly above it.  Empty 
columns contain no holes.</li>
     <li style="padding-bottom: 14px;"><b>Total Column Transitions</b><br>A
 column transition is an empty cell adjacent to a solid cell (or vice 
versa) within the same column.  The changeover from the highest solid 
block in the column to the empty space above it is not considered a 
transition.  Similarly, the playfield floor is not compared to the cell 
directly above it.  As a result, a completely empty column has no 
transitions.</li>
     <li style="padding-bottom: 14px;"><b>Total Row Transitions</b><br>A
 row transition is an empty cell adjacent to a solid cell (or vice 
versa) within the same row.  Empty cells adjoining playfield walls are 
considered transitions.  The total is computed across all rows in the 
playfield.  However, rows that are completely empty do not contribute to
 the sum.</li>
    </ul>
    <p>El-Ashi suggested that useful weights could be found using <a href="http://en.wikipedia.org/wiki/Particle_swarm_optimization">particle swarm optimization (PSO)</a>,
 an algorithm that iteratively improves a population of candidate 
solutions by imitating the kinds of swarm behavior observed in nature.  
In this case, each candidate solution is a vector of weights and the 
fitness of a candidate is determined by playing Tetris; it is the total 
number of Tetriminos it survived through before reaching game over.</p>
    <p>These ideas were applied to the <a href="#Java_Version">Java version</a>,
 which is discussed below; it executes outside of FCEUX and it can be 
configured to play against a non-graphical, in-memory game that runs at a
 considerably faster rate.  After setting up the PSO, I was surprised to
 find that it did not progress beyond the initial iteration.  As it 
happened, several of the randomly generally candidate solutions were 
actually playing well.  Over a period of days, the size of that set 
dwindled until there was only 1 remaining.  Here are the values of that 
solution:</p>
    <table class="table1">
      <tbody><tr><th>Factor</th><th>Weight</th></tr>
      <tr><td style="text-align: left;">Total Lines Cleared</td><td style="text-align: right;"><span class="code"> 1.000000000000000</span></td></tr>
      <tr><td style="text-align: left;">Total Lock Height</td><td style="text-align: right;"><span class="code">12.885008263218383</span></td></tr>
      <tr><td style="text-align: left;">Total Well Cells</td><td style="text-align: right;"><span class="code">15.842707182438396</span></td></tr>
      <tr><td style="text-align: left;">Total Column Holes</td><td style="text-align: right;"><span class="code">26.894496507795950</span></td></tr>
      <tr><td style="text-align: left;">Total Column Transitions</td><td style="text-align: right;"><span class="code">27.616914062397015</span></td></tr>
      <tr><td style="text-align: left;">Total Row Transitions</td><td style="text-align: right;"><span class="code">30.185110719279040</span></td></tr>      
    </tbody></table>
    <p>The playfields are evaluated by multiplying the factors with 
their associated weights and adding up the results.  A lower evaluation 
implies a better rating.  Since the factors and weights are all positive
 values, all the factors have an adverse influence; each of them should 
be minimized.  It also means that the best possible rating is 0.</p>
    <p>Since these weights were selected by random chance, there must be
 a very wide range of suitable values.  This particular set of numbers 
and the relative significance it suggests about each factor may be 
inconsequential.  But, scrutinizing them is interesting nonetheless.</p>
    <p>The least adverse factor is Total Lines Cleared.  The fact that 
this is even an adverse factor is counterintuitive.  But, the primary 
goal of the AI is survival.  It does not aim for a high score.  Rather, 
it plays conservatively, usually clearing lines individually.  To score a
 Double, a Triple or a Tetris, it would have to let the pile grow, which
 goes against its long term goal.</p>
    <p>The next on the list is Total Lock Height.  This can be minimized
 by getting the Tetriminos as close to the floor of the playfield as 
possible.  It’s a basic strategy that contributes to long term survival 
and short term packing by attracting pieces to the bottom.</p>
    <p>The weight assigned to Total Well Cells is bit a surprising 
because expert players intentionally build deep wells with the goal of 
scoring repeated Tetrises.  But, as mentioned, that’s risky play that 
goes against the main objective of survival.  In addition, the number of
 well cells provides an indication of pile roughness.  A certain level 
of roughness is beneficial in accommodating certain pieces or piece 
combinations.  But, high roughness is detrimental to tight packing.</p>
    <p>Total Column Holes is equal to approximately half of the Total 
Column Transitions.  Those factors can be combined and further folded 
into the final related factor resulting in the broader and most adverse 
factor: Total Transitions.</p>
    <p>Densely packed regions exhibit few transitions in all directions.
  Hence, the main strategy driving the AI can be summarized as: pack the
 pieces as closely together as possible.</p>
    
    <h3><a id="Other_Factors">Other Factors</a></h3>
    <p>Here is a list of some of the other factors that I experimented with while developing the AI:</p>
    <ul>    
      <li style="padding-bottom: 14px;"><b>Pile Height</b><br>Solid 
blocks can be suspended over empty cells producing overhangs and holes; 
however, it is not possible to fix solid blocks above completely empty 
rows.  Consequentially, pile height is the number of rows that contain 
at least one solid block.</li>
      <li style="padding-bottom: 14px;"><b>Total Occupied Columns</b><br>This is the number of columns containing at least 1 solid cell.</li>
      <li style="padding-bottom: 14px;"><b>Total Solid Cells</b><br>This is the number of solid cells in the playfield.</li>
      <li style="padding-bottom: 14px;"><b>Total Connected Regions</b><br>This applies the <a href="http://en.wikipedia.org/wiki/Flood_fill">flood fill algorithm</a>
 to count the number of contiguously connected regions.  It identifies 
holes that span both dimensions in addition to finding solid islands.</li>
      <li style="padding-bottom: 14px;"><b>Column Height Variance</b><br>This is the statistical measure of how far the heights are spread out from each other.  It’s a measure of surface roughness.</li>      
      <li style="padding-bottom: 14px;"><b>Total Accommodations</b><br>This
 computes how accommodating the pile is to the next unknown piece.  It 
counts the total number of ways that the 7 different piece types can be 
added to the playfield without introducing any holes.  An accurate count
 would require repeatedly applying BFS.  But, the search tree can be 
highly pruned to produce an approximation.</li>
      <li style="padding-bottom: 14px;"><b>Average Next Evaluation</b><br>This
 deepens the search by analyzing all possibilities for the next unknown 
piece.  It uses the other factors to independently place each piece type
 and then it returns the average of the 7 evaluations.  Each placement 
requires a BFS execution.</li>
      <li style="padding-bottom: 14px;"><b>Average Simulated Play</b><br>This
 simulates a series of short runs of Tetris play, picking pieces with 
its own pseudorandom number generator and using the AI to deal with 
them.  At the end of each run, the modified playfield is evaluated using
 the other factors.  The average of the runs is returned.</li>
    </ul>
    <p>All of the factors can be adjusted by introducing tunable 
parameters.  For example, instead of simply counting lines cleared, a 
different weight could be assigned to Singles, Doubles, Triples and 
Tetrises, mimicking the point system.  If more than one simultaneously 
cleared line really is detrimental to the long term goal of survival, 
then Singles could be assigned a negative weight where as the others 
would get positive weights.</p>
    <p>Another useful parameter is an offset value.  For instance, a 
pile surface that is completely flat has a column height variance of 0. 
 But, a perfectly flat surface is not accommodating to S and Z and other
 piece combinations.  As such, the variance should be centered about the
 optimal roughness by subtracting a constant.</p>
    <p>The tuned and offset factors can be raised to some power or they 
can be scaled logarithmically or exponentially, and so on, before 
computing the weighted sum.  All of these possibilities can be treated 
as additional weights, which can potentially be optimized using methods 
like PSO.</p>
    <p>Many of the factors provide insight into how well the pile would 
handle additional pieces, such as those dealing with surface roughness, 
but Total Accommodations, Average Next Evaluation and Average Simulated 
Play evaluate the modified playfield by actually inserting pieces beyond
 the 2 known ones.  In examining successive pieces, the amount of 
additional knowledge gained diminishes with depth due to rapid line 
erasure.  Meaning, just as distant past play is not that important, 
distant future play is not that important either.  In fact, if a short 
sequence of pieces were randomly misplaced, the AI would quickly 
recover, using the next few pieces to clear out the affected lines.  
Determining the optimal amount of successive piece analysis will require
 further research.</p>
    <p>Another consideration in the usefulness of a factor is 
computational cost.  Costs are greatly amplified because the evaluation 
function is invoked for every possible placement of the 2 pieces.  
Since, the AI should be able to play Tetris in real-time, expensive 
factors that provide valuable information may have to be sacrificed for 
more approximate techniques that execute faster.</p>
    
    <h3><a id="AI_Training">AI Training</a></h3>
    <p>Pathological sequences exist that will end the game regardless of
 the strategy.  The simplest example is an endless alternating sequence 
of S and Z Tetriminos, which, as demonstrated by the animation below, 
rapidly pushes the AI over the brink.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/63.gif"></p>
    <p>Since it can take days to run a candidate AI to completion and 
multiple runs are required to establish an average, it is completely 
impractical to use average run length as the metric to drive PSO.  
Instead, during evaluation, the difficulty of the game can be raised at a
 controlled rate by increasing the frequency of S and Z, eventually 
leading into the terminal alternating sequence.</p>
    <p>I tried this method of training, but I found that teaching it how
 to deal with frequent S and Z pieces was actually detrimental to its 
ability to handle uniformly distributed random pieces.</p>
    <p>In an alternative method, inspired by the B-Type game, the line 
clear rate serves as the metric directing the PSO.  The playfield is 
setup with 10 rows of random garbage blocks and every time a row is 
cleared, a new garbage row pushes up from the bottom, restoring the pile
 height.  Since the playfield is 10 columns wide and each Tetrimino 
consists of 4 squares, on average, the AI must clear a line every 2.5 
Tetriminos.  And, to remove garbage, it must do it even faster.</p>
    <p>Unfortunately, this technique also did not improve the 
performance.  One possible reason is that the random holes in garbage do
 not accurately represent the kind of rows it deals with during actual 
game play.  Also, line clearing is a short-term goal; greedily clearing 
them out does not necessarily improve long-term survival.  Occasionally,
 lines need to be left intact to deal with certain successive piece 
combinations.</p>    
    <p>On his web page, <a href="http://www.colinfahey.com/tetris/tetris.html">Colin Fahey</a>
 suggested a different method.  He produced histograms depicting the 
percentage of pieces that locked within each row over sample runs.  
Interestingly, all the histograms look virtually identical regardless of
 the number of pieces sampled.  From this, he proposed that it should be
 possible to use curve fitting on any sample run to estimate the 
statistical expectation of a piece locking in the spawn row and hence, 
how long the AI would play until game over.  I decided to examine this 
possibility.</p>
    <p>Below is a heat map generated from multiple sample runs, 
collectively consisting of 2,039,900,000 Tetriminos.  Each cell is 
colored based on the percentage of pieces which locked there.  The 
nonlinear palette was selected to enhance visual contrast.  It was 
produced by normalizing the cell values, via dividing by the maximum 
cell percentage, and then raising that to the 0.19 power (see <a href="http://en.wikipedia.org/wiki/Gamma_correction">gamma correction</a>).</p>
    <table class="img">
      <tbody><tr>
        <td><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/71.png"></td>
        <td>
          <table class="table1">
            <tbody><tr><th>Color</th><th>Percent</th></tr>
            <tr><td style="background-color: #000000;"></td><td><span class="code">0.00000000</span></td></tr>
            <tr><td style="background-color: #0066FF;"></td><td><span class="code">0.00000315</span></td></tr>
            <tr><td style="background-color: #00CCFF;"></td><td><span class="code">0.00024227</span></td></tr>
            <tr><td style="background-color: #00FFCC;"></td><td><span class="code">0.00307038</span></td></tr>
            <tr><td style="background-color: #00FF66;"></td><td><span class="code">0.01860818</span></td></tr>
            <tr><td style="background-color: #00FF00;"></td><td><span class="code">0.07527774</span></td></tr>
            <tr><td style="background-color: #66FF00;"></td><td><span class="code">0.23582574</span></td></tr>
            <tr><td style="background-color: #CCFF00;"></td><td><span class="code">0.61928352</span></td></tr>
            <tr><td style="background-color: #FFCC00;"></td><td><span class="code">1.42923040</span></td></tr>
            <tr><td style="background-color: #FF6600;"></td><td><span class="code">2.98867416</span></td></tr>
            <tr><td style="background-color: #FF0000;"></td><td><span class="code">5.78182519</span></td></tr>      
          </tbody></table>
        </td>
      </tr>
    </tbody></table>
    <p>The dark orange and red band in rows 17 and 18 indicate where the
 vast majority of pieces end up.  The chartreuse hue below it is a 
consequence of piece geometry; only 4 of the 7 Tetrimino types can lock 
in the bottom row.  In fact, the lower corners are black, revealing that
 it is impossible to lock there.</p>
    <p>The color across each row is nearly homogenous suggesting that 
pieces tend to be uniformly distributed horizontally.  The slight 
discontinuities can be explained by observing the histograms of the 
individual piece types:</p>
    <table class="img">
      <tbody><tr><td><b>T</b><br><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/64.png"></td><td><b>J</b><br><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/65.png"></td><td><b>Z</b><br><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/66.png"></td><td><b>O</b><br><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/67.png"></td><td><b>S</b><br><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/68.png"></td><td><b>L</b><br><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/69.png"></td><td><b>I</b><br><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/70.png"></td></tr>
    </tbody></table> 
    <p>T appears to be the most versatile type; its histogram is more 
uniform than any of the others.  The anomalies in J’s histogram are a 
result of the walls; only <span class="code">Jr</span> and <span class="code">Jl</span>
 can exist in the side columns, forcing the AI to uses columns 1 and 9 
more often to compensate. The same idea applies to L.  The histograms of
 Z and S look nearly identical, highlighting the imbalance that exists 
because <span class="code">Zv</span> and <span class="code">Sv</span> 
are not perfect mirrors of each other.  O is constrained to a 19×9 
playfield and it appears that the AI has a tendency of using O at the 
sides more often than the center.  The I Tetrimino is biased toward the 
right because of where its origin is located; locking in column 1 is a 
rarity as a result.</p>
    <p>The table below depicts the percentage of pieces that locked within each row.</p>
    <table class="table1">
      <tbody><tr><th>Row</th><th>Percent</th></tr>
      <tr><td>0</td><td class="num">0.0000000000</td></tr>
      <tr><td>1</td><td class="num">0.0000000000</td></tr>
      <tr><td>2</td><td class="num">0.0000004902</td></tr>
      <tr><td>3</td><td class="num">0.0000026472</td></tr>
      <tr><td>4</td><td class="num">0.0000066180</td></tr>
      <tr><td>5</td><td class="num">0.0000172557</td></tr>
      <tr><td>6</td><td class="num">0.0000512280</td></tr>
      <tr><td>7</td><td class="num">0.0001759400</td></tr>
      <tr><td>8</td><td class="num">0.0006681210</td></tr>
      <tr><td>9</td><td class="num">0.0023187901</td></tr>
      <tr><td>10</td><td class="num">0.0077928820</td></tr>
      <tr><td>11</td><td class="num">0.0259672043</td></tr>
      <tr><td>12</td><td class="num">0.0866187068</td></tr>
      <tr><td>13</td><td class="num">0.2901315751</td></tr>
      <tr><td>14</td><td class="num">0.9771663807</td></tr>
      <tr><td>15</td><td class="num">3.3000408353</td></tr>
      <tr><td>16</td><td class="num">10.6989059268</td></tr>
      <tr><td>17</td><td class="num">28.5687976371</td></tr>
      <tr><td>18</td><td class="num">50.0335706162</td></tr>
      <tr><td>19</td><td class="num">6.0077671454</td></tr>     
    </tbody></table>
    <p>Here is a plot of the values:</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/72.png"></p>
    <p>Not including row 19, the plot appears to depict exponential growth.</p>
    <p>Below is a list of the ratios of the number of locked pieces in adjacent rows.</p>    
    <table class="table1">
      <tbody><tr><th>Row<sub>A</sub>/Row<sub>B</sub></th><th>Ratio (%)</th></tr>
      <tr><td>1/2</td><td>0.00</td></tr>
      <tr><td>2/3</td><td>18.52</td></tr>
      <tr><td>3/4</td><td>40.00</td></tr>
      <tr><td>4/5</td><td>38.35</td></tr>
      <tr><td>5/6</td><td>33.68</td></tr>
      <tr><td>6/7</td><td>29.12</td></tr>
      <tr><td>7/8</td><td>26.33</td></tr>
      <tr><td>8/9</td><td>28.81</td></tr>
      <tr><td>9/10</td><td>29.76</td></tr>
      <tr><td>10/11</td><td>30.01</td></tr>
      <tr><td>11/12</td><td>29.98</td></tr>
      <tr><td>12/13</td><td>29.85</td></tr>
      <tr><td>13/14</td><td>29.69</td></tr>
      <tr><td>14/15</td><td>29.61</td></tr>
      <tr><td>15/16</td><td>30.84</td></tr>
      <tr><td>16/17</td><td>37.45</td></tr>
      <tr><td>17/18</td><td>57.10</td></tr>
      <tr><td>18/19</td><td>832.81</td></tr>           
    </tbody></table>
    <p>Rows <span class="nowrap">16–19</span> involve pieces interacting with the playfield floor; so, they will be precluded.  Rows <span class="nowrap">0–5</span>
 have too few samples to be meaningful.  The remaining ratios, pairs 
6/7–14/15, are almost identical; their average is 29.24%.  It means that
 probability of the pile growing taller by one row is roughly the same 
regardless of the height of pile.  This makes sense because the rules of
 Tetris limit interactivity to the top of the pile when it is densely 
packed.</p>
    <p>Below is a plot of log<sub>10</sub> of the percentage of pieces in rows 6–15.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/83.png"></p>
    <p>It is close to a perfectly straight line with a <a href="http://en.wikipedia.org/wiki/Coefficient_of_determination">coefficient of determination</a> that is nearly 1.  The formula derived from the <a href="http://en.wikipedia.org/wiki/Simple_linear_regression">linear regression</a> shown above provides a y-intercept that suggests that the percentage of pieces in row 0 is approximately 10<sup>−7.459</sup>%.  The reciprocal of that yields a statistical expectation of 2,877,688,349 Tetriminos or 1,151,075,340 lines until game over.</p>
    <p>This assumes that the log<sub>10</sub> of the percentage of 
pieces in each row remains linear all the way down to row 0.  However, 
when the pile nearly reaches the playfield ceiling, the freedom of 
movement maybe constrained to the point that this property breaks down. 
 Also, locking in row 0 does not necessarily guarantee game over; it is 
possible to recover as long as there is room to spawn.</p>    
    <p>Another way to evaluate the strength of an AI is to measure the 
average number of spawns between full clears of the playfield.  A full 
clear can be achieved in as few as 5 Tetriminos.  For instance, among 
many other possibilities, 5 Os laid side-by-side on the floor of the 
playfield will do it.  In general, since each Tetrimino consists of 4 
squares and the playfield is 10 squares wide, the number of spawns 
between full clears must be a multiple of 5 (because <i>4×5n = 2×10n</i>).</p> 
    <p>For this AI, the average number of spawns between full clears is 
1181, a relatively small number.  Since a full clear is equivalent to 
restarting the game, a complete run can be thought of as an extremely 
long series of restarts followed by a quick trip to game over.  Like the
 alternating <span class="nowrap">S-Z</span> sequence above, the pathological sequences that kill it are typically very short.</p>
    <p>The histogram below depicts the probability (as a percent) that 
the AI will achieve a full clear after a specified number of spawns.</p>    
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/76.png"></p>  
    <p>The magnitude of the exponent in the formula above determines the
 rate of decay and presumably the strength of the AI.  According to that
 formula, approximately 0.4% or about 1 in every 253 of the runs that 
start from an empty playfield will end in a full clear after only 5 
Tetriminos.</p>
    <p>Contrary to what Fahey proposed, the constants in the linear and exponential fits require a very large sample size before R<sup>2</sup>
 approaches 1, making them unsuitable for PSO.  But, the constants 
derived from long runs could be used to optimize an approximation 
function that produces estimates of the constants from short runs.  In a
 kind of development feedback loop, an optimized approximation function 
could be used by a PSO that enhances the AI, which could in turn be used
 to compute new constants to serve as benchmarks for improving the 
approximation function.</p>

    <h3><a id="Java_Version">Java Version</a></h3>
    
    <h4><a id="About2">About</a></h4>
    <p>For developers that are not familiar with Lua, the <a href="http://meatfighter.com/nintendotetrisai/NintendoTetrisAI.zip">source zip</a> includes a Java port of the AI.  The classes are a nearly line-by-line translation of the <a href="http://lua-users.org/wiki/ObjectOrientationTutorial">closure-based Lua objects</a>.</p>
    
    <h4><a id="Packages">Packages</a></h4>
    <p>The code is organized into 2 packages:</p>
    <ul>
      <li><span class="code">tetris.ai</span> contains the AI classes and interfaces.</li>
      <li><span class="code">tetris.gui</span> provides a visual representation of the playfield.</li>
    </ul>
    
    <h4><a id="AI_Classes_and_Interfaces">AI Classes and Interfaces</a></h4>

    <p>The aptly named <span class="code">Tetriminos</span> class describes Tetriminos.  It acts like an <span class="code">enum</span> containing constants for all of the Tetrimino types:</p>
    <div class="centered"><div class="source"><pre><span style="color: #008800; font-weight: bold">public</span> <span style="color: #008800; font-weight: bold">static</span> <span style="color: #008800; font-weight: bold">final</span> <span style="color: #333399; font-weight: bold">int</span> NONE <span style="color: #333333">=</span> <span style="color: #333333">-</span><span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">;</span>
<span style="color: #008800; font-weight: bold">public</span> <span style="color: #008800; font-weight: bold">static</span> <span style="color: #008800; font-weight: bold">final</span> <span style="color: #333399; font-weight: bold">int</span> T <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span><span style="color: #333333">;</span>
<span style="color: #008800; font-weight: bold">public</span> <span style="color: #008800; font-weight: bold">static</span> <span style="color: #008800; font-weight: bold">final</span> <span style="color: #333399; font-weight: bold">int</span> J <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">;</span>
<span style="color: #008800; font-weight: bold">public</span> <span style="color: #008800; font-weight: bold">static</span> <span style="color: #008800; font-weight: bold">final</span> <span style="color: #333399; font-weight: bold">int</span> Z <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">2</span><span style="color: #333333">;</span>
<span style="color: #008800; font-weight: bold">public</span> <span style="color: #008800; font-weight: bold">static</span> <span style="color: #008800; font-weight: bold">final</span> <span style="color: #333399; font-weight: bold">int</span> O <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">3</span><span style="color: #333333">;</span>
<span style="color: #008800; font-weight: bold">public</span> <span style="color: #008800; font-weight: bold">static</span> <span style="color: #008800; font-weight: bold">final</span> <span style="color: #333399; font-weight: bold">int</span> S <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">4</span><span style="color: #333333">;</span>
<span style="color: #008800; font-weight: bold">public</span> <span style="color: #008800; font-weight: bold">static</span> <span style="color: #008800; font-weight: bold">final</span> <span style="color: #333399; font-weight: bold">int</span> L <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">5</span><span style="color: #333333">;</span>
<span style="color: #008800; font-weight: bold">public</span> <span style="color: #008800; font-weight: bold">static</span> <span style="color: #008800; font-weight: bold">final</span> <span style="color: #333399; font-weight: bold">int</span> I <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">6</span><span style="color: #333333">;</span></pre></div></div>
    <p><span class="code">NONE</span> represents unassigned.  It is used for the empty cells of the playfield.</p>   
    <p><span class="code">Tetriminos</span> also contains 2 representations of the orientation table.  <span class="code">PATTERNS</span>
 is a 4-dimensional integer array (type × rotation × square × 
coordinates) containing the relative square coordinates; the rows are 
ordered such that within each type the spawn orientation appears first. 
 <span class="code">ORIENTATIONS</span>, the other representation, is a 2-dimenstional array (type × rotation) of <span class="code">Orientation</span> objects.  Each <span class="code">Orientation</span> contains the square coordinates as an array of <span class="code">Point</span> objects.  It also provides fields describing the range of legal positions for that orientation.</p>
    <div class="centered"><div class="source"><pre><span style="color: #008800; font-weight: bold">public</span> <span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">Orientation</span> <span style="color: #333333">{</span>
  <span style="color: #008800; font-weight: bold">public</span> Point<span style="color: #333333">[]</span> squares <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">new</span> Point<span style="color: #333333">[</span><span style="color: #0000DD; font-weight: bold">4</span><span style="color: #333333">];</span>
  <span style="color: #008800; font-weight: bold">public</span> <span style="color: #333399; font-weight: bold">int</span> minX<span style="color: #333333">;</span>
  <span style="color: #008800; font-weight: bold">public</span> <span style="color: #333399; font-weight: bold">int</span> maxX<span style="color: #333333">;</span>
  <span style="color: #008800; font-weight: bold">public</span> <span style="color: #333399; font-weight: bold">int</span> maxY<span style="color: #333333">;</span>
  <span style="color: #333333">...</span>
<span style="color: #333333">}</span></pre></div></div>
    <div class="centered"><div class="source"><pre><span style="color: #008800; font-weight: bold">public</span> <span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">Point</span> <span style="color: #333333">{</span>
  <span style="color: #008800; font-weight: bold">public</span> <span style="color: #333399; font-weight: bold">int</span> x<span style="color: #333333">;</span>
  <span style="color: #008800; font-weight: bold">public</span> <span style="color: #333399; font-weight: bold">int</span> y<span style="color: #333333">;</span>
  <span style="color: #333333">...</span>
<span style="color: #333333">}</span></pre></div></div>
    <p>The Tetrimino rotation—the second index in both orientation tables—appears in the <span class="code">State</span> objects that are manipulated by the BFS.</p>
    <div class="centered"><div class="source"><pre><span style="color: #008800; font-weight: bold">public</span> <span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">State</span> <span style="color: #333333">{</span>
  <span style="color: #008800; font-weight: bold">public</span> <span style="color: #333399; font-weight: bold">int</span> x<span style="color: #333333">;</span>
  <span style="color: #008800; font-weight: bold">public</span> <span style="color: #333399; font-weight: bold">int</span> y<span style="color: #333333">;</span>
  <span style="color: #008800; font-weight: bold">public</span> <span style="color: #333399; font-weight: bold">int</span> rotation<span style="color: #333333">;</span>
  <span style="color: #008800; font-weight: bold">public</span> <span style="color: #333399; font-weight: bold">int</span> visited<span style="color: #333333">;</span>
  <span style="color: #008800; font-weight: bold">public</span> State predecessor<span style="color: #333333">;</span> 
  <span style="color: #008800; font-weight: bold">public</span> State next<span style="color: #333333">;</span>
  <span style="color: #333333">...</span>
<span style="color: #333333">}</span></pre></div></div>
    <p>Collectively, <span class="code">x</span>, <span class="code">y</span> and <span class="code">rotation</span>
 describe the position and orientation of a piece.  Since the Tetrimino 
type remains constant from spawn to lock, a field for it is unnecessary.</p>
    <p>The <span class="code">Searcher</span> class, which houses the BFS algorithm, creates the complete set of all possible <span class="code">State</span> objects upon construction:</p>
    <div class="centered"><div class="source"><pre><span style="color: #008800; font-weight: bold">private</span> <span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">createStates</span><span style="color: #333333">()</span> <span style="color: #333333">{</span>
  states <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">new</span> State<span style="color: #333333">[</span>AI<span style="color: #333333">.</span><span style="color: #0000CC">PLAYFIELD_HEIGHT</span><span style="color: #333333">][</span>AI<span style="color: #333333">.</span><span style="color: #0000CC">PLAYFIELD_WIDTH</span><span style="color: #333333">][</span><span style="color: #0000DD; font-weight: bold">4</span><span style="color: #333333">];</span>
  <span style="color: #008800; font-weight: bold">for</span><span style="color: #333333">(</span><span style="color: #333399; font-weight: bold">int</span> y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span><span style="color: #333333">;</span> y <span style="color: #333333">&lt;</span> AI<span style="color: #333333">.</span><span style="color: #0000CC">PLAYFIELD_HEIGHT</span><span style="color: #333333">;</span> y<span style="color: #333333">++)</span> <span style="color: #333333">{</span>
    <span style="color: #008800; font-weight: bold">for</span><span style="color: #333333">(</span><span style="color: #333399; font-weight: bold">int</span> x <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span><span style="color: #333333">;</span> x <span style="color: #333333">&lt;</span> AI<span style="color: #333333">.</span><span style="color: #0000CC">PLAYFIELD_WIDTH</span><span style="color: #333333">;</span> x<span style="color: #333333">++)</span> <span style="color: #333333">{</span>        
      <span style="color: #008800; font-weight: bold">for</span><span style="color: #333333">(</span><span style="color: #333399; font-weight: bold">int</span> rotation <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span><span style="color: #333333">;</span> rotation <span style="color: #333333">&lt;</span> <span style="color: #0000DD; font-weight: bold">4</span><span style="color: #333333">;</span> rotation<span style="color: #333333">++)</span> <span style="color: #333333">{</span> 
        states<span style="color: #333333">[</span>y<span style="color: #333333">][</span>x<span style="color: #333333">][</span>rotation<span style="color: #333333">]</span> <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">new</span> State<span style="color: #333333">(</span>x<span style="color: #333333">,</span> y<span style="color: #333333">,</span> rotation<span style="color: #333333">);</span>
      <span style="color: #333333">}</span>
    <span style="color: #333333">}</span>
  <span style="color: #333333">}</span>
<span style="color: #333333">}</span></pre></div></div>
    <p>Although Java provides an ample Collections API, <span class="code">Searcher</span> contains a proprietary queue implementation.  The <span class="code">Queue</span> class uses <span class="code">State.next</span> to chain <span class="code">State</span> objects into a linked list.  Since all the <span class="code">State</span> objects are pre-allocated and each <span class="code">State</span>
 may be enqueued at most once, the queue is able to operate in-place, 
avoiding the overhead of temporary container objects present in generic 
queue implementations.</p>
    <p>The heart of the BFS is the <span class="code">search</span> method reproduced below.</p>    
    <div class="centered"><div class="source"><pre><span style="color: #008800; font-weight: bold">public</span> <span style="color: #333399; font-weight: bold">boolean</span> <span style="color: #0066BB; font-weight: bold">search</span><span style="color: #333333">(</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">[][]</span> playfield<span style="color: #333333">,</span> <span style="color: #333399; font-weight: bold">int</span> tetriminoType<span style="color: #333333">,</span> <span style="color: #333399; font-weight: bold">int</span> id<span style="color: #333333">)</span> <span style="color: #333333">{</span>

  <span style="color: #333399; font-weight: bold">int</span> maxRotation <span style="color: #333333">=</span> Tetriminos<span style="color: #333333">.</span><span style="color: #0000CC">ORIENTATIONS</span><span style="color: #333333">[</span>tetriminoType<span style="color: #333333">].</span><span style="color: #0000CC">length</span> <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">;</span>

  <span style="color: #333399; font-weight: bold">int</span> mark <span style="color: #333333">=</span> globalMark<span style="color: #333333">++;</span>

  <span style="color: #008800; font-weight: bold">if</span> <span style="color: #333333">(!</span>addChild<span style="color: #333333">(</span>playfield<span style="color: #333333">,</span> tetriminoType<span style="color: #333333">,</span> mark<span style="color: #333333">,</span> <span style="color: #008800; font-weight: bold">null</span><span style="color: #333333">,</span> <span style="color: #0000DD; font-weight: bold">5</span><span style="color: #333333">,</span> <span style="color: #0000DD; font-weight: bold">0</span><span style="color: #333333">,</span> <span style="color: #0000DD; font-weight: bold">0</span><span style="color: #333333">))</span> <span style="color: #333333">{</span>
    <span style="color: #008800; font-weight: bold">return</span> <span style="color: #008800; font-weight: bold">false</span><span style="color: #333333">;</span>
  <span style="color: #333333">}</span>    

  <span style="color: #008800; font-weight: bold">while</span><span style="color: #333333">(</span>queue<span style="color: #333333">.</span><span style="color: #0000CC">isNotEmpty</span><span style="color: #333333">())</span> <span style="color: #333333">{</span>
    State state <span style="color: #333333">=</span> queue<span style="color: #333333">.</span><span style="color: #0000CC">dequeue</span><span style="color: #333333">();</span>

    <span style="color: #008800; font-weight: bold">if</span> <span style="color: #333333">(</span>maxRotation <span style="color: #333333">!=</span> <span style="color: #0000DD; font-weight: bold">0</span><span style="color: #333333">)</span> <span style="color: #333333">{</span>
      addChild<span style="color: #333333">(</span>playfield<span style="color: #333333">,</span> tetriminoType<span style="color: #333333">,</span> mark<span style="color: #333333">,</span> state<span style="color: #333333">,</span> state<span style="color: #333333">.</span><span style="color: #0000CC">x</span><span style="color: #333333">,</span> state<span style="color: #333333">.</span><span style="color: #0000CC">y</span><span style="color: #333333">,</span> 
          state<span style="color: #333333">.</span><span style="color: #0000CC">rotation</span> <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">0</span> <span style="color: #333333">?</span> maxRotation <span style="color: #333333">:</span> state<span style="color: #333333">.</span><span style="color: #0000CC">rotation</span> <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">);</span>
      <span style="color: #008800; font-weight: bold">if</span> <span style="color: #333333">(</span>maxRotation <span style="color: #333333">!=</span> <span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">)</span> <span style="color: #333333">{</span>
        addChild<span style="color: #333333">(</span>playfield<span style="color: #333333">,</span> tetriminoType<span style="color: #333333">,</span> mark<span style="color: #333333">,</span> state<span style="color: #333333">,</span> state<span style="color: #333333">.</span><span style="color: #0000CC">x</span><span style="color: #333333">,</span> state<span style="color: #333333">.</span><span style="color: #0000CC">y</span><span style="color: #333333">,</span> 
            state<span style="color: #333333">.</span><span style="color: #0000CC">rotation</span> <span style="color: #333333">==</span> maxRotation <span style="color: #333333">?</span> <span style="color: #0000DD; font-weight: bold">0</span> <span style="color: #333333">:</span> state<span style="color: #333333">.</span><span style="color: #0000CC">rotation</span> <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">);</span>
      <span style="color: #333333">}</span>
    <span style="color: #333333">}</span>

    addChild<span style="color: #333333">(</span>playfield<span style="color: #333333">,</span> tetriminoType<span style="color: #333333">,</span> mark<span style="color: #333333">,</span> state<span style="color: #333333">,</span> 
        state<span style="color: #333333">.</span><span style="color: #0000CC">x</span> <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">,</span> state<span style="color: #333333">.</span><span style="color: #0000CC">y</span><span style="color: #333333">,</span> state<span style="color: #333333">.</span><span style="color: #0000CC">rotation</span><span style="color: #333333">);</span>
    addChild<span style="color: #333333">(</span>playfield<span style="color: #333333">,</span> tetriminoType<span style="color: #333333">,</span> mark<span style="color: #333333">,</span> state<span style="color: #333333">,</span> 
        state<span style="color: #333333">.</span><span style="color: #0000CC">x</span> <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">,</span> state<span style="color: #333333">.</span><span style="color: #0000CC">y</span><span style="color: #333333">,</span> state<span style="color: #333333">.</span><span style="color: #0000CC">rotation</span><span style="color: #333333">);</span>

    <span style="color: #008800; font-weight: bold">if</span> <span style="color: #333333">(!</span>addChild<span style="color: #333333">(</span>playfield<span style="color: #333333">,</span> tetriminoType<span style="color: #333333">,</span> mark<span style="color: #333333">,</span> state<span style="color: #333333">,</span>
        state<span style="color: #333333">.</span><span style="color: #0000CC">x</span><span style="color: #333333">,</span> state<span style="color: #333333">.</span><span style="color: #0000CC">y</span> <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">,</span> state<span style="color: #333333">.</span><span style="color: #0000CC">rotation</span><span style="color: #333333">))</span> <span style="color: #333333">{</span>
      lockTetrimino<span style="color: #333333">(</span>playfield<span style="color: #333333">,</span> tetriminoType<span style="color: #333333">,</span> id<span style="color: #333333">,</span> state<span style="color: #333333">);</span>
    <span style="color: #333333">}</span>
  <span style="color: #333333">}</span>

  <span style="color: #008800; font-weight: bold">return</span> <span style="color: #008800; font-weight: bold">true</span><span style="color: #333333">;</span>
<span style="color: #333333">}</span></pre></div></div>
    <p>It seeds the queue with the state of a spawned Tetrimino and then
 it successively derives children from dequeues states, adding them back
 to the queue as it sprawls the playfield.</p>
    <p>The playfield, containing a mixture of solid and empty cells, the
 Tetrimino type to spawn and an arbitrary identifier are passed into the
 <span class="code">search</span> method.  As it performs the BFS, the listener is called back every time a lock position is discovered.</p>
    <div class="centered"><div class="source"><pre><span style="color: #008800; font-weight: bold">public</span> <span style="color: #008800; font-weight: bold">interface</span> <span style="color: #BB0066; font-weight: bold">ISearchListener</span> <span style="color: #333333">{</span>  
  <span style="color: #008800; font-weight: bold">public</span> <span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">handleResult</span><span style="color: #333333">(</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">[][]</span> playfield<span style="color: #333333">,</span> <span style="color: #333399; font-weight: bold">int</span> tetriminoType<span style="color: #333333">,</span> 
      <span style="color: #333399; font-weight: bold">int</span> id<span style="color: #333333">,</span> State state<span style="color: #333333">);</span>
<span style="color: #333333">}</span></pre></div></div>
    <p>The listener receives a modified playfield containing the 
Tetrimino locked in place.  The Tetrimino spawn type and the arbitrary 
identifier are also passed through.  The final parameter is the <span class="code">State</span> where the Tetrimino locked.  By following the chain of <span class="code">State.predecessor</span> links, it is possible to recover the pathway all the way back to the spawn <span class="code">State</span>.</p>
    <p><span class="code">State.visited</span> could have been implemented as a <span class="code">boolean</span>; however, that would have entailed the overhead of iterating over all the <span class="code">State</span> objects prior to the search to reset <span class="code">visited</span> to <span class="code">false</span>.  Instead, <span class="code">visited</span> is an <span class="code">int</span>, which is compared against a count that is incremented every time <span class="code">search</span> is called.</p>
    <p>The <span class="code">addChild</span> method provisionally 
enqueues successor states.  The successor must be within the bounds of 
the playfield and it must be situated over 4 empty playfield cells.  In 
addition, the successor must be an unvisited <span class="code">State</span>.  If the position is legal, <span class="code">addChild</span> returns <span class="code">true</span>, even if the successor failed to be enqueued because it was already visited.</p>  
    <p>The <span class="code">search</span> method uses the <span class="code">addChild</span>
 return value to detect if it is possible to spawn.  If it cannot spawn,
 then the pile reached the top and there is no searching to be done; so,
 it returns <span class="code">false</span>.</p>
    <p>The <span class="code">addChild</span> return value is also 
inspected in the attempt to advance downward one step.  If that fails, 
then the current state represents a lock position, triggering a call to <span class="code">lockTetrimino</span>.  The <span class="code">lockTetrimino</span> method modifies the playfield, it calls the listener and then it restores the playfield.</p>    
    <p>Each row of the <span class="code">playfield</span> array contains 1 extra element that stores the number of solid cells within the row.  The element is incremented by <span class="code">lockTetrimino</span> as it sets cells to solid.</p>
    <p>When the listener receives the modified playfield, it calls <span class="code">PlayfieldUtil.clearRows</span>
 to remove completed lines; the method detects them by examining the 
value in the extra row element.  To remove a row, the code takes 
advantage of the fact that in Java, 2-dimensional arrays are actually 
arrays-of-arrays; it simply shifts down the row references.  <span class="code">PlayfieldUtil</span>
 contains spare rows and it completes the clear by inserting a reference
 to one of them at top.  Before the shift happens, the index of the 
row-to-be-cleared is saved in the row’s extra element.  Then, the row 
reference is pushed onto a stack.</p>  
    <p>The listener eventually calls <span class="code">PlayfieldUtil.restoreRows</span>
 to undo the changes to the playfield.  The steps are undone in reverse 
order.  First, the spare row is retrieved from the top.  Then, the 
completed row is popped off the stack and the index is recovered from 
the extra element.  It is used to shift the row references and to 
position the removed row back into place.  Finally, the extra element is
 restored by setting it to the playfield width, the number of solid 
cells in a completed line.</p>
    <p><span class="code">PlayfieldUtil</span> also provides the <span class="code">evaluatePlayfield</span> method, which computes and captures 4 of the evaluation factors into the container class listed below.</p>
    <div class="centered"><div class="source"><pre><span style="color: #008800; font-weight: bold">public</span> <span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">PlayfieldEvaluation</span> <span style="color: #333333">{</span>
  <span style="color: #008800; font-weight: bold">public</span> <span style="color: #333399; font-weight: bold">int</span> holes<span style="color: #333333">;</span>
  <span style="color: #008800; font-weight: bold">public</span> <span style="color: #333399; font-weight: bold">int</span> columnTransitions<span style="color: #333333">;</span>
  <span style="color: #008800; font-weight: bold">public</span> <span style="color: #333399; font-weight: bold">int</span> rowTransitions<span style="color: #333333">;</span>
  <span style="color: #008800; font-weight: bold">public</span> <span style="color: #333399; font-weight: bold">int</span> wells<span style="color: #333333">;</span>
<span style="color: #333333">}</span>
</pre></div></div>
    <p>Governing it all is the <span class="code">AI</span> class.  It contains 2 <span class="code">Searcher</span> objects chained together by the listener shown below.</p>
    <div class="centered"><div class="source"><pre><span style="color: #008800; font-weight: bold">public</span> <span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">handleResult</span><span style="color: #333333">(</span>
    <span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">[][]</span> playfield<span style="color: #333333">,</span> <span style="color: #333399; font-weight: bold">int</span> tetriminoType<span style="color: #333333">,</span> <span style="color: #333399; font-weight: bold">int</span> id<span style="color: #333333">,</span> State state<span style="color: #333333">)</span> <span style="color: #333333">{</span>

  <span style="color: #008800; font-weight: bold">if</span> <span style="color: #333333">(</span>id <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">0</span><span style="color: #333333">)</span> <span style="color: #333333">{</span>
    result0 <span style="color: #333333">=</span> state<span style="color: #333333">;</span>
  <span style="color: #333333">}</span>

  Orientation orientation 
      <span style="color: #333333">=</span> Tetriminos<span style="color: #333333">.</span><span style="color: #0000CC">ORIENTATIONS</span><span style="color: #333333">[</span>tetriminoType<span style="color: #333333">][</span>state<span style="color: #333333">.</span><span style="color: #0000CC">rotation</span><span style="color: #333333">];</span>
  <span style="color: #333399; font-weight: bold">int</span> rows <span style="color: #333333">=</span> playfieldUtil<span style="color: #333333">.</span><span style="color: #0000CC">clearRows</span><span style="color: #333333">(</span>playfield<span style="color: #333333">,</span> state<span style="color: #333333">.</span><span style="color: #0000CC">y</span><span style="color: #333333">);</span>
  <span style="color: #333399; font-weight: bold">int</span> originalTotalRows <span style="color: #333333">=</span> totalRows<span style="color: #333333">;</span>
  <span style="color: #333399; font-weight: bold">int</span> originalTotalDropHeight <span style="color: #333333">=</span> totalDropHeight<span style="color: #333333">;</span>
  totalRows <span style="color: #333333">+=</span> rows<span style="color: #333333">;</span>
  totalDropHeight <span style="color: #333333">+=</span> orientation<span style="color: #333333">.</span><span style="color: #0000CC">maxY</span> <span style="color: #333333">-</span> state<span style="color: #333333">.</span><span style="color: #0000CC">y</span><span style="color: #333333">;</span>

  <span style="color: #333399; font-weight: bold">int</span> nextID <span style="color: #333333">=</span> id <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">;</span>

  <span style="color: #008800; font-weight: bold">if</span> <span style="color: #333333">(</span>nextID <span style="color: #333333">==</span> tetriminoIndices<span style="color: #333333">.</span><span style="color: #0000CC">length</span><span style="color: #333333">)</span> <span style="color: #333333">{</span>

    playfieldUtil<span style="color: #333333">.</span><span style="color: #0000CC">evaluatePlayfield</span><span style="color: #333333">(</span>playfield<span style="color: #333333">,</span> e<span style="color: #333333">);</span>

    <span style="color: #333399; font-weight: bold">double</span> fitness <span style="color: #333333">=</span> computeFitness<span style="color: #333333">();</span>
    <span style="color: #008800; font-weight: bold">if</span> <span style="color: #333333">(</span>fitness <span style="color: #333333">&lt;</span> bestFitness<span style="color: #333333">)</span> <span style="color: #333333">{</span>
      bestFitness <span style="color: #333333">=</span> fitness<span style="color: #333333">;</span>
      bestResult <span style="color: #333333">=</span> result0<span style="color: #333333">;</span>
    <span style="color: #333333">}</span>
  <span style="color: #333333">}</span> <span style="color: #008800; font-weight: bold">else</span> <span style="color: #333333">{</span>
    searchers<span style="color: #333333">[</span>nextID<span style="color: #333333">].</span><span style="color: #0000CC">search</span><span style="color: #333333">(</span>playfield<span style="color: #333333">,</span> tetriminoIndices<span style="color: #333333">[</span>nextID<span style="color: #333333">],</span> nextID<span style="color: #333333">);</span>
  <span style="color: #333333">}</span>

  totalDropHeight <span style="color: #333333">=</span> originalTotalDropHeight<span style="color: #333333">;</span>
  totalRows <span style="color: #333333">=</span> originalTotalRows<span style="color: #333333">;</span>
  playfieldUtil<span style="color: #333333">.</span><span style="color: #0000CC">restoreRows</span><span style="color: #333333">(</span>playfield<span style="color: #333333">,</span> rows<span style="color: #333333">);</span>
<span style="color: #333333">}</span></pre></div></div>
    <p>The <span class="code">AI</span> class is actually designed to handle any number of <span class="code">Searcher</span> objects, but Nintendo Tetris only provides 1 preview piece.  The <span class="code">Searcher</span>
 objects are stored in an array and the code above serves as a common 
listener for all of them.  The arbitrary identifier passed into the <span class="code">Searcher.search</span>
 method is actually the index into the array, which is also the search 
depth.  When the listener is invoked, the identifier directs the call to
 the next <span class="code">Searcher</span> in the chain.  If it 
reached the end of the array, then it evaluates the playfield.  And, 
when it encounters a playfield with a better fitness, it records the 
locked <span class="code">State</span> from the first <span class="code">Searcher</span> in the chain.</p>
    <p><span class="code">AI</span> provides a <span class="code">search</span> method that accepts a playfield and an array containing the spawn and next Tetriminos types.  It returns the <span class="code">State</span>
 containing the position and rotation where the first Tetrimino should 
lock.  It makes no commitment to the second Tetrimino; on the subsequent
 call, it will reevaluate everything.  If the pile is very high and <span class="code">Searcher</span> chain fails to place both Tetriminos, <span class="code">AI.search</span> will return <span class="code">null</span>.</p>
    <div class="centered"><div class="source"><pre><span style="color: #008800; font-weight: bold">public</span> State <span style="color: #0066BB; font-weight: bold">search</span><span style="color: #333333">(</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">[][]</span> playfield<span style="color: #333333">,</span> <span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">[]</span> tetriminoIndices<span style="color: #333333">)</span> <span style="color: #333333">{</span>

  <span style="color: #008800; font-weight: bold">this</span><span style="color: #333333">.</span><span style="color: #0000CC">tetriminoIndices</span> <span style="color: #333333">=</span> tetriminoIndices<span style="color: #333333">;</span>
  bestResult <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">null</span><span style="color: #333333">;</span>
  bestFitness <span style="color: #333333">=</span> Double<span style="color: #333333">.</span><span style="color: #0000CC">MAX_VALUE</span><span style="color: #333333">;</span>

  searchers<span style="color: #333333">[</span><span style="color: #0000DD; font-weight: bold">0</span><span style="color: #333333">].</span><span style="color: #0000CC">search</span><span style="color: #333333">(</span>playfield<span style="color: #333333">,</span> tetriminoIndices<span style="color: #333333">[</span><span style="color: #0000DD; font-weight: bold">0</span><span style="color: #333333">],</span> <span style="color: #0000DD; font-weight: bold">0</span><span style="color: #333333">);</span>

  <span style="color: #008800; font-weight: bold">return</span> bestResult<span style="color: #333333">;</span>
<span style="color: #333333">}</span>
</pre></div></div>
    
    <h4><a id="Invoking_the_AI">Invoking the AI</a></h4>
    <p>Since the Java version is not anchored to FCEUX, it can 
potentially be used in other projects.  For those interested integrating
 the AI into something else, this section covers what that entails.</p>
    <p>First, create an instance of <span class="code">AI</span>, an instance of <span class="code">PlayfieldUtil</span> and an array to store the known Tetrimino types.  Also, instantiate the playfield by calling <span class="code">PlayfieldUtil.createPlayfield</span>;
 it returns a 2-dimensional array with the additional column discussed 
earlier.  You’ll probably also require a random number generator.</p>
    <div class="centered"><div class="source"><pre>AI ai <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">new</span> AI<span style="color: #333333">();</span>
PlayfieldUtil playfieldUtil <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">new</span> PlayfieldUtil<span style="color: #333333">();</span>
<span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">[]</span> tetriminos <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">new</span> <span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">[</span>AI<span style="color: #333333">.</span><span style="color: #0000CC">TETRIMINOS_SEARCHED</span><span style="color: #333333">];</span>
<span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">[][]</span> playfield <span style="color: #333333">=</span> playfieldUtil<span style="color: #333333">.</span><span style="color: #0000CC">createPlayfield</span><span style="color: #333333">();</span>
Random random <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">new</span> Random<span style="color: #333333">();</span></pre></div></div>
    <p>The playfield starts out empty with all cells set to <span class="code">Tetriminos.NONE</span>.  If you programmatically fill cells, be sure to set <span class="code">playfield[rowIndex][AI.PLAYFIELD_WIDTH]</span> to the number of solid cells in each row.</p>
    <p>Fill the Tetrimino types array with the initial spawn and next types, which are normally selected randomly.</p>
    <div class="centered"><div class="source"><pre>tetriminos<span style="color: #333333">[</span><span style="color: #0000DD; font-weight: bold">0</span><span style="color: #333333">]</span> <span style="color: #333333">=</span> random<span style="color: #333333">.</span><span style="color: #0000CC">nextInt</span><span style="color: #333333">(</span><span style="color: #0000DD; font-weight: bold">7</span><span style="color: #333333">);</span>
tetriminos<span style="color: #333333">[</span><span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">]</span> <span style="color: #333333">=</span> random<span style="color: #333333">.</span><span style="color: #0000CC">nextInt</span><span style="color: #333333">(</span><span style="color: #0000DD; font-weight: bold">7</span><span style="color: #333333">);</span></pre></div></div>
    <p>Then, pass the playfield and the types array to the <span class="code">AI.search</span> method.  It will return the <span class="code">State</span> where the first Tetrimino should lock.  If it returns <span class="code">null</span>, then game over is inevitable.</p>
    <div class="centered"><div class="source"><pre>State state <span style="color: #333333">=</span> ai<span style="color: #333333">.</span><span style="color: #0000CC">search</span><span style="color: #333333">(</span>playfield<span style="color: #333333">,</span> tetriminos<span style="color: #333333">);</span></pre></div></div>
    <p>If you need the pathway from spawn to lock, then pass the <span class="code">State</span> to the <span class="code">AI.buildStateList</span> method.</p>
    <div class="centered"><div class="source"><pre>State<span style="color: #333333">[]</span> states <span style="color: #333333">=</span> ai<span style="color: #333333">.</span><span style="color: #0000CC">buildStatesList</span><span style="color: #333333">(</span>state<span style="color: #333333">);</span></pre></div></div>
    <p>To update the playfield, pass it to <span class="code">PlayfieldUtil.lockTetrimino</span> along with its type and the <span class="code">State</span> object.  That method will automatically clear completed lines.</p>
    <div class="centered"><div class="source"><pre>playfieldUtil<span style="color: #333333">.</span><span style="color: #0000CC">lockTetrimino</span><span style="color: #333333">(</span>playfield<span style="color: #333333">,</span> tetriminos<span style="color: #333333">[</span><span style="color: #0000DD; font-weight: bold">0</span><span style="color: #333333">],</span> state<span style="color: #333333">);</span></pre></div></div>
    <p>Before calling <span class="code">AI.search</span> again, the next Tetrimino needs to be randomly selected.</p>
    <div class="centered"><div class="source"><pre>tetriminos<span style="color: #333333">[</span><span style="color: #0000DD; font-weight: bold">0</span><span style="color: #333333">]</span> <span style="color: #333333">=</span> tetriminos<span style="color: #333333">[</span><span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">];</span>    
tetriminos<span style="color: #333333">[</span><span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">]</span> <span style="color: #333333">=</span> random<span style="color: #333333">.</span><span style="color: #0000CC">nextInt</span><span style="color: #333333">(</span><span style="color: #0000DD; font-weight: bold">7</span><span style="color: #333333">);</span></pre></div></div>
    <p>Putting it all together looks like this:</p>
    <div class="centered"><div class="source"><pre>AI ai <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">new</span> AI<span style="color: #333333">();</span>
PlayfieldUtil playfieldUtil <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">new</span> PlayfieldUtil<span style="color: #333333">();</span>
<span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">[]</span> tetriminos <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">new</span> <span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">[</span>AI<span style="color: #333333">.</span><span style="color: #0000CC">TETRIMINOS_SEARCHED</span><span style="color: #333333">];</span>
<span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">[][]</span> playfield <span style="color: #333333">=</span> playfieldUtil<span style="color: #333333">.</span><span style="color: #0000CC">createPlayfield</span><span style="color: #333333">();</span>
Random random <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">new</span> Random<span style="color: #333333">();</span>

tetriminos<span style="color: #333333">[</span><span style="color: #0000DD; font-weight: bold">0</span><span style="color: #333333">]</span> <span style="color: #333333">=</span> random<span style="color: #333333">.</span><span style="color: #0000CC">nextInt</span><span style="color: #333333">(</span><span style="color: #0000DD; font-weight: bold">7</span><span style="color: #333333">);</span>
tetriminos<span style="color: #333333">[</span><span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">]</span> <span style="color: #333333">=</span> random<span style="color: #333333">.</span><span style="color: #0000CC">nextInt</span><span style="color: #333333">(</span><span style="color: #0000DD; font-weight: bold">7</span><span style="color: #333333">);</span>

<span style="color: #008800; font-weight: bold">while</span><span style="color: #333333">(</span><span style="color: #008800; font-weight: bold">true</span><span style="color: #333333">)</span> <span style="color: #333333">{</span>

  <span style="color: #888888">// ... print playfield ...</span>

  State state <span style="color: #333333">=</span> ai<span style="color: #333333">.</span><span style="color: #0000CC">search</span><span style="color: #333333">(</span>playfield<span style="color: #333333">,</span> tetriminos<span style="color: #333333">);</span>

  <span style="color: #008800; font-weight: bold">if</span> <span style="color: #333333">(</span>state <span style="color: #333333">==</span> <span style="color: #008800; font-weight: bold">null</span><span style="color: #333333">)</span> <span style="color: #333333">{</span>
    <span style="color: #008800; font-weight: bold">break</span><span style="color: #333333">;</span> <span style="color: #888888">// game over</span>
  <span style="color: #333333">}</span>

  playfieldUtil<span style="color: #333333">.</span><span style="color: #0000CC">lockTetrimino</span><span style="color: #333333">(</span>playfield<span style="color: #333333">,</span> tetriminos<span style="color: #333333">[</span><span style="color: #0000DD; font-weight: bold">0</span><span style="color: #333333">],</span> state<span style="color: #333333">);</span>

  tetriminos<span style="color: #333333">[</span><span style="color: #0000DD; font-weight: bold">0</span><span style="color: #333333">]</span> <span style="color: #333333">=</span> tetriminos<span style="color: #333333">[</span><span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">];</span>    
  tetriminos<span style="color: #333333">[</span><span style="color: #0000DD; font-weight: bold">1</span><span style="color: #333333">]</span> <span style="color: #333333">=</span> random<span style="color: #333333">.</span><span style="color: #0000CC">nextInt</span><span style="color: #333333">(</span><span style="color: #0000DD; font-weight: bold">7</span><span style="color: #333333">);</span>
<span style="color: #333333">}</span></pre></div></div>
    <p>Rather than printing out the playfield, there is a more interesting way to view what is going on...</p>
      
    <h4><a id="Displaying_the_Playfield">Displaying the Playfield</a></h4>
    <p>The <span class="code">TetrisFrame</span> class simulates the visuals of Nintendo Tetris including all the quirks discussed in earlier sections.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/77.png"></p>
    <p>To see it in action, launch <span class="code">tetris.gui.Main</span>.  As with the Lua version, you can adjust the play speed by modifying a constant at the top of the file.</p>
    <div class="centered"><div class="source"><pre><span style="color: #008800; font-weight: bold">public</span> <span style="color: #008800; font-weight: bold">static</span> <span style="color: #008800; font-weight: bold">final</span> <span style="color: #333399; font-weight: bold">boolean</span> PLAY_FAST <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">true</span><span style="color: #333333">;</span></pre></div></div>
    <p><span class="code">TetrisFrame</span> provides 4 methods for manipulating the screen.  The <span class="code">displayTetrimino</span> method renders the active Tetrimino at the specified coordinates.  It accepts a <span class="code">delay</span> parameter, which causes the method to wait for that number of animation frames before returning.</p>
    <div class="centered"><div class="source"><pre><span style="color: #008800; font-weight: bold">public</span> <span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">displayTetrimino</span><span style="color: #333333">(</span><span style="color: #333399; font-weight: bold">int</span> type<span style="color: #333333">,</span> <span style="color: #333399; font-weight: bold">int</span> rotation<span style="color: #333333">,</span> <span style="color: #333399; font-weight: bold">int</span> x<span style="color: #333333">,</span> <span style="color: #333399; font-weight: bold">int</span> y<span style="color: #333333">,</span> <span style="color: #333399; font-weight: bold">int</span> delay<span style="color: #333333">)</span></pre></div></div>
    <p>The <span class="code">lockTetrimino</span> method fixes a piece 
into place.  The lines counter, the score, the level and the Tetrimino 
colors will update accordingly, exhibiting the expected peculiar 
behaviors as the values increase beyond the intended limits.  Setting 
the <span class="code">animate</span> parameter to <span class="code">true</span>
 enables line clearing animations, flashing the display when a Tetris is
 achieved.  The method will block until animations complete.</p>
    <div class="centered"><div class="source"><pre><span style="color: #008800; font-weight: bold">public</span> <span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">lockTetrimino</span><span style="color: #333333">(</span><span style="color: #333399; font-weight: bold">int</span> type<span style="color: #333333">,</span> <span style="color: #333399; font-weight: bold">int</span> rotation<span style="color: #333333">,</span> <span style="color: #333399; font-weight: bold">int</span> x<span style="color: #333333">,</span> <span style="color: #333399; font-weight: bold">int</span> y<span style="color: #333333">,</span> <span style="color: #333399; font-weight: bold">boolean</span> animate<span style="color: #333333">)</span></pre></div></div>
    <p><span class="code">updateStatisticsAndNext</span> increments the stats counter for the newly spawned Tetrimino and it updates the preview piece.</p>
    <div class="centered"><div class="source"><pre><span style="color: #008800; font-weight: bold">public</span> <span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">updateStatisticsAndNext</span><span style="color: #333333">(</span><span style="color: #333399; font-weight: bold">int</span> activeTetrimino<span style="color: #333333">,</span> <span style="color: #333399; font-weight: bold">int</span> nextTetrimino<span style="color: #333333">)</span></pre></div></div>
    <p>The <span class="code">dropTetrimino</span> method will spawn a piece and it will let it drop under gravity, making no attempt to rotate or position it.  <span class="code">Main</span> uses it for the final 2 pieces when <span class="code">AI.search</span> returns <span class="code">null</span>.  If the <span class="code">animate</span> parameter is <span class="code">true</span>,
 the game over curtain will come down upon spawn failure.  As with the 
other methods, this one blocks until all animations complete.  It 
returns <span class="code">true</span> only if it is able spawn into the crowded playfield.</p>
    <div class="centered"><div class="source"><pre><span style="color: #008800; font-weight: bold">public</span> <span style="color: #333399; font-weight: bold">boolean</span> <span style="color: #0066BB; font-weight: bold">dropTetrimino</span><span style="color: #333333">(</span><span style="color: #333399; font-weight: bold">int</span> type<span style="color: #333333">,</span> <span style="color: #333399; font-weight: bold">boolean</span> animate<span style="color: #333333">)</span></pre></div></div>
    <p>Those 4 methods should be invoked by a worker thread, but the <span class="code">TetrisFrame</span> itself should be created on the Event Dispatch Thread.  Refer to the <span class="code">Main</span> class to see how this is done.</p>
    <p>For fun, <span class="code">Main</span> uses <span class="code">Randomizer</span>, a class that simulates the biased pseudorandom number generator in Nintendo Tetris.</p>
    <p>The <span class="code">tetris.gui.images</span> package contains display related files.  <span class="code">tiles.png</span> is the pattern table, containing all the tile graphics.  <span class="code">background.dat</span> stores tile ids that collectively make up the background; the data was pulled from <span class="code">$BF3F</span>.  And, <span class="code">colors.dat</span> contains the bytes that generate the unusual square colors that manifest themselves starting at level 138.</p>
    <p><span class="code">ImageLoader</span> contains the NES palette table and <span class="code">ImagePane</span> possesses the full set of level display values.</p>
    
    <h4><a id="Other_Projects">Other Projects</a></h4>
    <p>The code could potentially be used in place of a recording for 
demo mode.  In fact, such a demo could be rendered perpetual by taking 
advantage of how rapidly the AI is able to clear the entire playfield.  
To accomplish this, the pseudorandom number generator would be seeded 
with by some arbitary constant, producing a deterministic sequence of 
Tetriminos.  The first 2 Tetriminos of the sequence would be recorded.  
When the AI achieves a full clear, the next 2 Tetriminos would be 
compared against the first 2 of sequence.  If they match—an event 
expected every 49 full clears, on the average—then the pseudorandom 
number generator could be reseeded with the original constant, producing
 an endless demo loop.  The length of the loop could be made very large 
to obscure the fact that it is a loop at all.  And, the demo could start
 at a random point of the loop, providing a different demo each time.</p>
    <p>Another potential use of the AI is for player versus computer 
mode.  In multiplayer Tetris, when a group of rows are cleared 
simultaneously, garbage rows will push up from the bottom of the 
opponent’s playfield, lifting it upward.  The AI should be able to 
defend itself against garbage for the same reason it is able to play 
B-Type games.  However, as discussed earlier, the AI plays 
conservatively, tending to clear single rows at time.  Meaning, it will 
be able to guard against assault, but won’t be able to attack.  To 
provide the means of modifying this behavior, I created an interface 
called <span class="code">IChildFilter</span>.</p>
    <div class="centered"><div class="source"><pre><span style="color: #008800; font-weight: bold">public</span> <span style="color: #008800; font-weight: bold">interface</span> <span style="color: #BB0066; font-weight: bold">IChildFilter</span> <span style="color: #333333">{</span>
  <span style="color: #008800; font-weight: bold">public</span> <span style="color: #333399; font-weight: bold">boolean</span> <span style="color: #0066BB; font-weight: bold">validate</span><span style="color: #333333">(</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">[][]</span> playfield<span style="color: #333333">,</span> <span style="color: #333399; font-weight: bold">int</span> tetriminoType<span style="color: #333333">,</span>
      <span style="color: #333399; font-weight: bold">int</span> x<span style="color: #333333">,</span> <span style="color: #333399; font-weight: bold">int</span> y<span style="color: #333333">,</span> <span style="color: #333399; font-weight: bold">int</span> rotation<span style="color: #333333">);</span>
<span style="color: #333333">}</span></pre></div></div>
    <p><span class="code">AI</span> provides an alternate constructor that accepts an implementation of <span class="code">IChildFilter</span>.  When present, <span class="code">IChildFilter.validate</span> serves as an additional check for determining if a child state is legal; if it returns <span class="code">false</span>, then the child is not enqueued.</p>
    <p><span class="code">WellFilter</span> is an implementation of <span class="code">IChildFilter</span>
 that aims for Tetrises.  Like human players, it incrementally builds a 
well in the right-most column of playfield, row-by-row from the bottom 
up.  As it works on a row, it declines children that that would 
introduce a square in the right-most column.  When a row is completely 
solid except for the well column, it advances to the row above it.  When
 4 or more such rows are ready, it will permit an I Tetrimino to fill 
the well, achieving a Tetris.  Also, the pile height is monitored; if it
 grows too high, <span class="code">WellFilter</span> stops interfering with the AI.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/78.png"></p>
    <p>To try it out, make the following change to <span class="code">Main</span>:</p>
    <div class="centered"><div class="source"><pre>AI ai <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">new</span> AI<span style="color: #333333">(</span><span style="color: #008800; font-weight: bold">new</span> WellFilter<span style="color: #333333">());</span></pre></div></div>
    <p><span class="code">WellFilter</span> works, but not very 
efficiently.  It contains a simple heuristic intended to demonstrate the
 concept.  To obtain Tetrises more often will require a more elaborate 
strategy, perhaps something that could be optimized by PSO.</p>
    <p>It is also possible to use child state filtering to generate art.  Below is an example of what <span class="code">PatternFilter</span> can do.</p>    
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/79.png"></p>
    <p><span class="code">PatternFilter</span> builds up images row-by-row from the bottom up similar to how <span class="code">WellFilter</span> functions; however, instead of keeping the right-most column empty, <span class="code">PatternFilter</span> only accepts children that maintain a particular pattern.</p>
    <p>The constructor of <span class="code">PatternFilter</span> accepts the name one of the image files in the <span class="code">tetris.gui.patterns</span>
 package, which it uses as a template.  Each 20×10 image contains black 
and white pixels corresponding to cells of the playfield.</p>
    <div class="centered"><div class="source"><pre>AI ai <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">new</span> AI<span style="color: #333333">(</span><span style="color: #008800; font-weight: bold">new</span> PatternFilter<span style="color: #333333">(</span><span style="background-color: #fff0f0">"tetriminos"</span><span style="color: #333333">));</span></pre></div></div>    
    <p>The line above produces the silhouettes of the 7 Tetriminos shown below.</p>       
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/81.png"></p>
    <p>Another example follows, depicting a large T Tetrimino at an angle.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/80.png"></p>
    <p>Below is one more.  If you squint, you might be able to make out the title of the game.</p>
    <p><img src="Applying%20Artificial%20Intelligence%20to%20Nintendo%20Tetris_files/82.png"></p>
    <p>Like <span class="code">WellFilter</span>, <span class="code">PatternFilter</span>
 is nothing more than a proof of concept.  The patterns that it can 
handle are limited to the lower half of the playfield due to its 
tendency to reach game over before finishing them.  Nonetheless, it is 
an interesting idea worthy of further investigation.</p>
    
    <h3><a id="Gamepad_Version">Gamepad Version</a></h3>
    <p>The Lua script and the Java program ignore gravity; for them, the
 drop speed is irrelevant because, depending on the configuration, it 
either teleports pieces directly into lock or it carries them there 
along any pathway and rate that it desires.  In a sense, they are only 
imitating Tetris rather than playing it.  However, the <a href="http://meatfighter.com/nintendotetrisai/NintendoTetrisAI.zip">source zip</a>
 includes an alternate Lua script that plays entirely by generating 
gamepad button signals, allowing the game to govern the piece movements,
 gravity and all.</p>
    <p>Introducing gravity greatly increases the search space, forcing 
the AI to take into account the subtle rules used for manipulating 
pieces.  The details of these rules were discussed in prior sections and
 they can only be fully appreciated by directly studying the code, but 
here are the highlights:</p>
    <ul>
      <li>Pieces are updated in stages in the following order: shift, rotate, and drop.</li>
      <li>When Down is pressed, it is not possible to shift.</li>
      <li>When Left or Right is pressed, it is not possible to soft drop.</li>
      <li>It is possible to shift and rotate within the same frame.</li>
      <li>It is possible to rotate and soft drop within the same frame.</li> 
      <li>It is possible to shift and automatically drop within the same frame.</li>
      <li>It is possible to rotate and automatically drop within the same frame.</li>
      <li>It is possible to shift, rotate and automatically drop within the same frame.</li>
      <li>When A or B is pressed, it must be released for at least 1 frame before it can pressed again.</li>
      <li>Holding Left or Right causes the game to automatically shift 
every 6 frames after an initial delay of 16 frames.  It is possible to 
press and release Left or Right every other frame to shift pieces 
faster.</li>
      <li>Holding Down triggers a soft drop every other frame after an initial delay of 3 frames.</li>
      <li>The first spawned piece has an opening entry delay of 96 frames.  A soft drop will cancel it, but shifting and rotating won’t.</li>
    </ul>
    <p>To accommodate those rules, historical information needs to be 
incorporated into the search states.  It requires fields that express 
the number of frames that each button has been held and the number of 
frames since the last automatic drop.  Every unique set of 
values—including the <span class="nowrap">x-coordinate</span>, the <span class="nowrap">y-coordinate</span>
 and the rotation of the Tetrimino—characterizes a separate and distinct
 state.  Unfortunately, the number of possibilities is so vast that it 
is impractical to fully search that space.  Instead, the gamepad version
 of the AI only explores a subset of it.</p>
    <p>The AI uses a <span class="code">State</span> object with the following fields:</p>    
    <div class="centered"><div class="source"><pre>{ x, y, rotation, Left, Right, Down, A, B, fallTimer, visited, predecessor }</pre></div></div>
    <p>Rather than relying on the auto-shift, the AI presses and 
releases a shift button on alternate frames.  Consequentially, it only 
needs to keep track of whether the button is pressed or not, as opposed 
to how long it has been held.  Since there is no auto-rotate, the same 
idea applies to the A and B buttons.  As such, the <span class="code">Left</span>, <span class="code">Right</span>, <span class="code">A</span> and <span class="code">B</span> fields can be interpreted as enums containing one of these values:</p>
    <div class="centered"><div class="source"><pre>{ RELEASED, PRESSED } </pre></div></div>
    <p>On the other hand, to soft drop, the Down button must be initially held for 3 frames, necessitating 4 states:</p>
    <div class="centered"><div class="source"><pre>{ RELEASED, PRESSED_FOR_1_FRAME, PRESSED_FOR_2_FRAMES, PRESSED_FOR_3_FRAMES } </pre></div></div>    
    <p><span class="code">Down</span> incrementally advances from <span class="code">RELEASED</span> to <span class="code">PRESSED_FOR_3_FRAMES</span>, at which point a soft drop occurs.  From there, it can be <span class="code">RELEASED</span> or it can return to <span class="code">PRESSED_FOR_2_FRAMES</span>, providing a soft drop every other frame after the initial delay.  It is prohibiting from being <span class="code">RELEASED</span> from <span class="code">PRESSED_FOR_1_FRAME</span> or <span class="code">PRESSED_FOR_2_FRAMES</span>.</p>
    <p>In actuality, integer constants are used in the Lua code, but the concept is the same.</p>
    <p>Like <span class="code">visited</span> and <span class="code">predecessor</span>, <span class="code">fallTimer</span> is an assigned value that is acquired when a child state is enqueued; its <span class="code">fallTimer</span> will be one greater than its parent’s value.  A state that contains a <span class="code">fallTimer</span> equal to the drop speed implies that an automatic drop occurs within that frame and the successors of that state will have a <span class="code">fallTimer</span> of 0.</p>
    <p>Each <span class="code">Searcher</span> pre-allocates an <span class="nowrap">8-dimensional</span> array containing all possible states (<span class="nowrap">20 rows</span> <span class="nowrap">× 10 columns</span> <span class="nowrap">× 4 rotations</span> <span class="nowrap">× 2 Lefts</span> <span class="nowrap">× 2 Rights</span> <span class="nowrap">× 4 Downs</span> <span class="nowrap">× 2 As</span> <span class="nowrap">× 2 Bs</span>) and the BFS acts analogously to the method presented for the <span class="nowrap">3-dimensional</span> array.  The pseudocode below details how successors are derived from dequeued states.</p>    
    <div class="centered"><div class="source"><pre>Slide <span style="color: #333333">=</span> (Left <span style="color: #333333">==</span> PRESSED) <span style="color: #000000; font-weight: bold">or</span> (Right <span style="color: #333333">==</span> PRESSED)
Rotate <span style="color: #333333">=</span> (A <span style="color: #333333">==</span> PRESSED) <span style="color: #000000; font-weight: bold">or</span> (B <span style="color: #333333">==</span> PRESSED)

<span style="color: #008800; font-weight: bold">if</span> Down <span style="color: #333333">==</span> RELEASED <span style="color: #000000; font-weight: bold">or</span> Down <span style="color: #333333">==</span> PRESSED_FOR_3_FRAMES <span style="color: #008800; font-weight: bold">then</span>  

  <span style="color: #008800; font-weight: bold">if</span> Down <span style="color: #333333">==</span> RELEASED <span style="color: #008800; font-weight: bold">then</span>
    nextDown <span style="color: #333333">=</span> PRESSED_FOR_1_FRAME
  <span style="color: #008800; font-weight: bold">else</span>
    nextDown <span style="color: #333333">=</span> PRESSED_FOR_2_FRAMES
  <span style="color: #008800; font-weight: bold">end</span>

  addChild(Down <span style="color: #333333">=</span> nextDown)

  <span style="color: #008800; font-weight: bold">if</span> <span style="color: #000000; font-weight: bold">not</span> Rotate <span style="color: #008800; font-weight: bold">then</span>
    addChild(A <span style="color: #333333">=</span> PRESSED, Down <span style="color: #333333">=</span> nextDown)
    addChild(B <span style="color: #333333">=</span> PRESSED, Down <span style="color: #333333">=</span> nextDown)
  <span style="color: #008800; font-weight: bold">end</span>

  <span style="color: #008800; font-weight: bold">if</span> Slide <span style="color: #008800; font-weight: bold">then</span>

    addChild()

    <span style="color: #008800; font-weight: bold">if</span> <span style="color: #000000; font-weight: bold">not</span> Rotate <span style="color: #008800; font-weight: bold">then</span>
      addChild(A <span style="color: #333333">=</span> PRESSED)
      addChild(B <span style="color: #333333">=</span> PRESSED)
    <span style="color: #008800; font-weight: bold">end</span>

  <span style="color: #008800; font-weight: bold">else</span>

    addChild(Left <span style="color: #333333">=</span> PRESSED)
    addChild(Right <span style="color: #333333">=</span> PRESSED)

    <span style="color: #008800; font-weight: bold">if</span> <span style="color: #000000; font-weight: bold">not</span> Rotate <span style="color: #008800; font-weight: bold">then</span>

      addChild(Left <span style="color: #333333">=</span> PRESSED, A <span style="color: #333333">=</span> PRESSED)
      addChild(Left <span style="color: #333333">=</span> PRESSED, B <span style="color: #333333">=</span> PRESSED)
      addChild(Right <span style="color: #333333">=</span> PRESSED, A <span style="color: #333333">=</span> PRESSED)
      addChild(Right <span style="color: #333333">=</span> PRESSED, B <span style="color: #333333">=</span> PRESSED)
      
    <span style="color: #008800; font-weight: bold">end</span>

  <span style="color: #008800; font-weight: bold">end</span>

<span style="color: #008800; font-weight: bold">else</span>

  <span style="color: #008800; font-weight: bold">if</span> Down <span style="color: #333333">==</span> PRESSED_FOR_1_FRAME <span style="color: #008800; font-weight: bold">then</span>
    nextDown <span style="color: #333333">=</span> PRESSED_FOR_2_FRAMES
  <span style="color: #008800; font-weight: bold">else</span>
    nextDown <span style="color: #333333">=</span> PRESSED_FOR_3_FRAMES
  <span style="color: #008800; font-weight: bold">end</span>

  addChild(Down <span style="color: #333333">=</span> nextDown)

  <span style="color: #008800; font-weight: bold">if</span> <span style="color: #000000; font-weight: bold">not</span> Rotate <span style="color: #008800; font-weight: bold">then</span>
    addChild(A <span style="color: #333333">=</span> PRESSED, Down <span style="color: #333333">=</span> nextDown)
    addChild(B <span style="color: #333333">=</span> PRESSED, Down <span style="color: #333333">=</span> nextDown)
  <span style="color: #008800; font-weight: bold">end</span>  

<span style="color: #008800; font-weight: bold">end</span></pre></div></div>
    <p>As illustrated by the pseudocode that follows, the <span class="code">addChild</span> function takes into account the order of events that occur within each frame (i.e. shift, rotate and drop).</p>
    <div class="centered"><div class="source"><pre>nextFallTimer <span style="color: #333333">=</span> fallTimer <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>

<span style="color: #008800; font-weight: bold">if</span> Left <span style="color: #333333">==</span> PRESSED <span style="color: #000000; font-weight: bold">and</span> testPosition(x <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>, y, rotation) <span style="color: #008800; font-weight: bold">then</span>
  x <span style="color: #333333">=</span> x <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>
<span style="color: #008800; font-weight: bold">elseif</span> Right <span style="color: #333333">==</span> PRESSED <span style="color: #000000; font-weight: bold">and</span> testPosition(x <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>, y, rotation) <span style="color: #008800; font-weight: bold">then</span>
  x <span style="color: #333333">=</span> x <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span> 
<span style="color: #008800; font-weight: bold">end</span>

<span style="color: #008800; font-weight: bold">if</span> A <span style="color: #333333">==</span> PRESSED <span style="color: #000000; font-weight: bold">and</span> testPosition(x, y, nextClockwiseRotation) <span style="color: #008800; font-weight: bold">then</span>
  rotation <span style="color: #333333">=</span> nextClockwiseRotation
<span style="color: #008800; font-weight: bold">elseif</span> B <span style="color: #333333">==</span> PRESSED <span style="color: #000000; font-weight: bold">and</span> testPosition(x, y, nextCounterclockwiseRotation) <span style="color: #008800; font-weight: bold">then</span>
  rotation <span style="color: #333333">=</span> nextCounterclockwiseRotation    
<span style="color: #008800; font-weight: bold">end</span>

<span style="color: #008800; font-weight: bold">if</span> Down <span style="color: #333333">==</span> PRESSED_FOR_3_FRAMES <span style="color: #000000; font-weight: bold">or</span> nextFallTimer <span style="color: #333333">&gt;=</span> dropSpeed <span style="color: #008800; font-weight: bold">then</span>
  <span style="color: #008800; font-weight: bold">if</span> testPosition(x, y <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>, rotation) <span style="color: #008800; font-weight: bold">then</span>
    y <span style="color: #333333">=</span> y <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>
    nextFallTimer <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>
  <span style="color: #008800; font-weight: bold">else</span>
    lockTetrimino()
    <span style="color: #008800; font-weight: bold">return</span>
  <span style="color: #008800; font-weight: bold">end</span>
<span style="color: #008800; font-weight: bold">end</span>       

childState <span style="color: #333333">=</span> states[y][x][rotation][Left][Right][Down][A][B]
<span style="color: #008800; font-weight: bold">if</span> <span style="color: #000000; font-weight: bold">not</span> childState.visited <span style="color: #008800; font-weight: bold">then</span>
  childState.visited <span style="color: #333333">=</span> mark
  childState.predecessor <span style="color: #333333">=</span> state  
  childState.fallTimer <span style="color: #333333">=</span> nextFallTimer  
  queue.enqueue(childState)
<span style="color: #008800; font-weight: bold">end</span></pre></div></div>
    <p>As in the prior version, <span class="code">AI.search</span> returns a chain of <span class="code">State</span> objects.  But, in this case, each <span class="code">State</span> contains the set of buttons to press within each frame.  The <span class="code">x</span>, <span class="code">y</span> and <span class="code">rotation</span> fields are not used for manipulating the pieces, but they can be used to verify that the pieces moved as expected.</p>
    <p>Although the search space was greatly reduced by imposing the 
constraints that are describe above, it still takes 1–3 seconds to 
complete the search.  If you run it, you’ll experience a pause every 
time a Tetrimino is spawned.  Also, the movements appear very unnatural;
 it tends to rotate the piece a moment before lock.  Nonetheless, it 
plays almost as well as the version that ignored gravity, even at the 
highest speed.</p>
    <p>To try it, launch <span class="code">lua/NintendoTetrisAIGamepadVersion.lua</span> located in the <a href="http://meatfighter.com/nintendotetrisai/NintendoTetrisAI.zip">source zip</a>.</p>
    <p>A simpler method to incorporate gravity is to restrict piece 
movement to a rotation followed by a shift followed by a drop to the 
bottom.  The idea is that by eliminating slides and spins, the rate at 
which pieces move vertically will have little effect on the AI; all it 
needs to do is to get a piece into the correct column and orientation 
and gravity will do the rest.  Another advantage of this technique is 
that the search space is very small, enabling it to play in real-time 
without computation delays.  However, the downside is that without 
slides and spins, it plays significantly worse.  Nevertheless, a Tetris 
AI that cannot play in real-time is less than useful.</p>
    <p class="img"><b>2014.01.28</b></p>
  

</body></html>